# Hardware Latency Tester v4.0 Architecture

This document captures the end-to-end system design for the v4.0 release. It is structured around the major subsystems that enable frame-accurate latency measurement, automated detection, and hardware-aware reporting while keeping the application as a portable single-page experience.

## 1. Media Engine
- **HTML5 Video Core:**
  - Primary playback uses the native `<video>` element with MediaSource Extensions for future streaming support.
  - Frame stepping is achieved via `requestVideoFrameCallback` (Chrome/Edge) with a fallback to timeupdate polling for browsers lacking support.
  - Playback rates 0.25×–4×, including jog forward/back (±1 frame, ±5 frames) bound to keyboard shortcuts (Space, J/K/L, arrow keys).
- **Timecode & Timeline Synchronization:**
  - Centralized `TimelineController` normalizes all temporal data into frame counts, supporting 30/60/120 FPS.
  - Timecode displayed as HH:MM:SS:FF with drop-frame awareness for 29.97 FPS assets.
  - Loop regions, playhead, and marker overlays subscribe to a shared timeline state store (React context + Zustand backing store for persistence).
- **Audio Integration:**
  - WaveSurfer.js renders channel waveforms using Web Audio API decoded buffers.
  - Waveform zoom/pan events propagate to the `TimelineController` so video, waveform, and markers remain in lockstep.
  - Audio channel mute/solo controls enable isolating key signals like controller clicks or reference tones.
- **Caching & Storage:**
  - IndexedDB stores decoded waveform data, generated thumbnails, and analysis artifacts keyed by media hash to avoid redundant processing.
  - LocalStorage caches UI preferences (playback rate, zoom level, theme) for rapid reloads.

## 2. Marker Management
- **Marker Types:** Eight marker templates are supported at launch: `TagOff`, `MotionStart`, `MotionPeak`, `MotionSettle`, `AudioCue`, `VisualCue`, `ValidationPass`, `ValidationFail`.
- **Creation & Editing:**
  - Users click the timeline or waveform to add markers; drag handles allow frame-level adjustments with snapping.
  - Marker Inspector side panel edits axis, direction, hardware profile, linked requirement, freeform notes, and pass/fail attribution.
  - Bulk operations (multi-select, delete, reassign axis) handled via keyboard shortcuts and list view controls.
- **Visualization:**
  - Marker overlays render above both video timeline and waveform, color-coded per type and axis.
  - Hover tooltips show timecode, confidence score (if auto-detected), and associated requirement thresholds.
- **Persistence:**
  - Markers stored in a normalized schema (`markers`, `markerEvents`, `requirements`) in IndexedDB for offline use.
  - Import/export flows support CSV (DaVinci Resolve-compatible), JSON (internal schema), and PDF snapshots.

## 3. Pattern Recognition
- **Template Training:**
  - Operators select a video region, label constituent sub-events, and save as a reusable template.
  - Templates capture video frame fingerprints (perceptual hash + optical flow deltas) and audio FFT profiles.
- **Detection Pipeline:**
  - Web Workers handle heavy computation: audio FFT, convolution across waveform, and video frame differencing.
  - Detection returns candidate markers with confidence scores; thresholds configurable per pattern/hardware combo.
  - Results presented in a review queue with accept/reject options and quick adjustments.
- **Library Management:**
  - Templates stored with metadata: hardware applicability, required markers, creator, revision history.
  - Sharing enabled via JSON export/import and optional cloud sync hook (future scope flagged for v4.1).

## 4. Hardware Management
- **Profiles:**
  - Each hardware profile records Tag type, version, firmware build, accessories, and calibration notes.
  - Requirements templates attach latency thresholds, axis tolerances, and marker expectations per hardware profile.
- **Assignment Workflow:**
  - Settings view exposes CRUD for profiles, including duplication and comparison diff.
  - Test cases link to active hardware profile; executions inherit profile + requirement snapshot for auditability.
- **Version Tracking:**
  - Change log maintained per profile (who, what, when) with ability to roll back to prior versions.
  - Validation layer warns when an execution references a deprecated firmware or mismatched accessory set.

## 5. Workflow Integration
- **End-to-End Pipeline:**
  1. Load video (drag-and-drop or file picker) → compute hash → cache assets.
  2. Assign hardware profile & requirements (or create new profile inline).
  3. Annotate markers manually or trigger auto-detection templates.
  4. Validate markers against requirements; flag discrepancies.
  5. Generate exports (CSV/JSON/PDF, optional annotated video) and share execution package.
- **Collaboration Hooks:**
  - Commenting system tied to markers with author attribution and status (open/resolved).
  - Session save files include comments, hardware linkage, and detection history for cross-team review.

## 6. Export Options
- **CSV:** DaVinci Resolve-compatible format with axis, hardware, requirement, and confidence columns.
- **JSON:** Full fidelity export mirroring internal schema for automation ingestion; versioned with schema ID.
- **PDF:** Report generator using Puppeteer (Headless Chrome) to produce print-quality PDF with embedded frames, summary statistics, and requirement compliance tables.
- **Annotated Video (optional):** FFmpeg.wasm pipeline overlays markers and timecodes directly into video; gated by feature flag to avoid default bundle bloat.
- **Packaging:** Export wizard bundles selected formats plus raw assets into a ZIP for archival.

## 7. Technology Stack & Performance
- **Framework:** React 18 with functional components and hooks; Tailwind CSS for utility-first styling consistent with v3.8.
- **State Management:** Combination of React Context for UI state and Zustand for persisted project data; immer for immutable updates.
- **Build System:** Vite for development/production builds targeting a single HTML output with inlined assets (≤150 KB baseline without FFmpeg.wasm).
- **Performance Strategies:** Lazy-load heavy modules (WaveSurfer, FFmpeg), virtualize long marker lists, debounce expensive computations, and offload pattern detection to Web Workers.

## 8. Security & Privacy
- All processing remains client-side; no media leaves the browser.
- IndexedDB entries scoped per origin; provide in-app controls to purge cached media and analysis artifacts.
- Optional encryption (password-protected ZIP) for export bundles planned as stretch goal.

## 9. Compliance & Accessibility
- WCAG 2.1 AA compliance via semantic markup, keyboard navigation, ARIA annotations, and high-contrast theme.
- Localization-ready UI strings stored centrally to support future language packs.
- Logging limited to in-browser console with redaction of personally identifiable information.

## 10. Open Questions
- Should we pre-bundle additional codecs (e.g., H.265/HEVC) via WASM decoders for non-MP4 formats?
- Do we need to integrate with external storage (OneDrive, SharePoint) for export delivery in v4.0, or defer?
- Is live capture support (webcam ingest) a priority for late-phase work, or earmarked for v4.1?

This architecture underpins the v4.0 implementation plan, ensuring each phase lands on a cohesive technical foundation that elevates the latency tester well beyond the v3.x lineage.
