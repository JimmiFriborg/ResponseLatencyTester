<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardware Latency Tester v3.9 Release Candidate</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React and Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .row-pass { background-color: rgba(34, 197, 94, 0.1); }
        .row-fail { background-color: rgba(239, 68, 68, 0.1); }
        .row-error { background-color: rgba(251, 191, 36, 0.1); }
        .row-excluded { background-color: rgba(156, 163, 175, 0.1); }
        @media print {
            .no-print { display: none !important; }
            body { background: white; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef } = React;

        const AXIS_KEYS = ['X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-'];
        const AXES = ['X', 'Y', 'Z'];
        const DISTANCE_AXES = ['X', 'Y', 'Z'];
        const DEFECT_STATUSES = ['Open', 'Investigating', 'In Progress', 'Blocked', 'Resolved'];
        const DEFECT_SEVERITIES = ['Low', 'Medium', 'High', 'Critical'];

        const createDefectRecord = (overrides = {}) => ({
            id: overrides.id || (Date.now().toString() + '_defect'),
            title: overrides.title || '',
            description: overrides.description || '',
            severity: overrides.severity || 'Medium',
            owner: overrides.owner || '',
            status: overrides.status || 'Open',
            lastUpdated: overrides.lastUpdated || new Date().toISOString()
        });

        const getDefaultEnvironment = () => ({
            name: '',
            location: '',
            owner: '',
            dut: '',
            notes: ''
        });

        const createHardwareItem = () => ({
            id: Date.now().toString() + Math.random(),
            type: '',
            version: '',
            revision: '',
            serialNumber: '',
            name: '',
            notes: ''
        });

        const getDefaultExecutionRequirements = () => ({
            enabled: false,
            maxLatency: 100,
            minRespondRanges: { X: 5, Y: 5, Z: 5 },
            mustNotRespondRanges: { X: 25, Y: 25, Z: 25 }
        });

        const mergeExecutionRequirements = (requirements = {}) => {
            const defaults = getDefaultExecutionRequirements();
            return {
                ...defaults,
                ...requirements,
                minRespondRanges: {
                    ...defaults.minRespondRanges,
                    ...(requirements?.minRespondRanges || {})
                },
                mustNotRespondRanges: {
                    ...defaults.mustNotRespondRanges,
                    ...(requirements?.mustNotRespondRanges || {})
                }
            };
        };

        const createRequirementTemplate = (overrides = {}) => ({
            id: overrides.id || (Date.now().toString() + '_req'),
            name: overrides.name || 'Requirement ' + new Date().toLocaleString(),
            description: overrides.description || '',
            config: mergeExecutionRequirements(overrides.config || {})
        });

        const convertLegacyRequirementsToConfig = (legacy = {}) => {
            const defaults = getDefaultExecutionRequirements();
            const base = mergeExecutionRequirements({
                enabled: legacy.enabled ?? defaults.enabled,
                maxLatency: legacy.maxLatency ?? defaults.maxLatency
            });
            const minRespondRanges = { ...base.minRespondRanges };
            const mustNotRespondRanges = { ...base.mustNotRespondRanges };
            AXES.forEach(axis => {
                const plusKey = axis + '+';
                const minusKey = axis + '-';
                const plusRange = legacy?.ranges?.[plusKey] || {};
                const minusRange = legacy?.ranges?.[minusKey] || {};
                minRespondRanges[axis] =
                    plusRange.minRespond ?? minusRange.minRespond ?? minRespondRanges[axis];
                mustNotRespondRanges[axis] =
                    plusRange.mustNotRespond ?? minusRange.mustNotRespond ?? mustNotRespondRanges[axis];
            });
            return {
                ...base,
                minRespondRanges,
                mustNotRespondRanges
            };
        };

        const normalizeDistances = (distances = {}) => {
            const normalized = {};
            DISTANCE_AXES.forEach(axis => {
                if (distances[axis] || distances[axis] === 0) {
                    normalized[axis] = distances[axis];
                    return;
                }
                const plusKey = axis + '+';
                const minusKey = axis + '-';
                if (distances[plusKey] || distances[plusKey] === 0) {
                    normalized[axis] = distances[plusKey];
                    return;
                }
                if (distances[minusKey] || distances[minusKey] === 0) {
                    normalized[axis] = distances[minusKey];
                }
            });
            return normalized;
        };

        const normalizeHardwareList = (hardware = []) => {
            return hardware.map(item => ({
                ...createHardwareItem(),
                ...item,
                id: item.id || (Date.now().toString() + Math.random())
            }));
        };

        const LatencyTester = () => {
            // State management
            const [testCases, setTestCases] = useState([]);
            const [activeTestCase, setActiveTestCase] = useState(null);
            const [activeExecution, setActiveExecution] = useState(null);
            const [comparisonExecutions, setComparisonExecutions] = useState([]);
            const [view, setView] = useState('execution'); // execution, comparison, report, traceability, defects
            const [showPassFailHighlight, setShowPassFailHighlight] = useState(true);
            const [selectedForReport, setSelectedForReport] = useState([]);
            const [requirementTemplates, setRequirementTemplates] = useState(() => [
                createRequirementTemplate({ name: 'Default Requirements' })
            ]);
            const [traceabilityFilter, setTraceabilityFilter] = useState('');
            const [importDialog, setImportDialog] = useState(null);
            const [defects, setDefects] = useState([]);
            const [defectFilter, setDefectFilter] = useState('');

            const importRef = useRef(null);

            useEffect(() => {
                fetch('v3.9-rc-defects.json')
                    .then(response => response.ok ? response.json() : null)
                    .then(data => {
                        if (data && Array.isArray(data.defects)) {
                            setDefects(data.defects.map(defect => createDefectRecord(defect)));
                        }
                    })
                    .catch(() => {
                        // When running from file:// the fetch will fail silently.
                    });
            }, []);

            const getRequirementTemplateById = (templateId) =>
                requirementTemplates.find(template => template.id === templateId);

            const cloneTemplateConfig = (templateId) => {
                const template = getRequirementTemplateById(templateId);
                return template ? mergeExecutionRequirements(template.config) : null;
            };

            const ensureTemplateConfig = (templateId) =>
                cloneTemplateConfig(templateId) || getDefaultExecutionRequirements();

            const syncTemplateToExecutions = (templateId, config) => {
                if (!templateId) return;
                setTestCases(prev => prev.map(tc => {
                    if (!tc.executions || tc.executions.length === 0) {
                        return tc;
                    }
                    const needsUpdate = tc.executions.some(ex => ex.requirementTemplateId === templateId);
                    if (!needsUpdate) {
                        return tc;
                    }
                    return {
                        ...tc,
                        executions: tc.executions.map(ex =>
                            ex.requirementTemplateId === templateId
                                ? { ...ex, requirements: mergeExecutionRequirements(config) }
                                : ex
                        )
                    };
                }));
            };

            const applyRequirementConfigChange = (config, field, value) => {
                const merged = mergeExecutionRequirements(config);
                if (field === 'minRespondRanges' || field === 'mustNotRespondRanges') {
                    return {
                        ...merged,
                        [field]: {
                            ...merged[field],
                            ...value
                        }
                    };
                }
                if (field === 'enabled') {
                    return {
                        ...merged,
                        enabled: value
                    };
                }
                return {
                    ...merged,
                    [field]: value
                };
            };

            const addRequirementTemplate = () => {
                const template = createRequirementTemplate({
                    name: `Requirement ${requirementTemplates.length + 1}`
                });
                setRequirementTemplates(prev => [...prev, template]);
                return template;
            };

            const deleteRequirementTemplate = (templateId) => {
                if (requirementTemplates.length <= 1) {
                    alert('At least one requirement template must remain.');
                    return;
                }
                setRequirementTemplates(prev => prev.filter(template => template.id !== templateId));
                setTestCases(prev => prev.map(tc => ({
                    ...tc,
                    requirementTemplateId: tc.requirementTemplateId === templateId ? null : tc.requirementTemplateId,
                    executions: tc.executions.map(ex =>
                        ex.requirementTemplateId === templateId
                            ? { ...ex, requirementTemplateId: null }
                            : ex
                    )
                })));
            };

            const updateRequirementTemplateDetails = (templateId, field, value) => {
                setRequirementTemplates(prev => prev.map(template =>
                    template.id === templateId ? { ...template, [field]: value } : template
                ));
            };

            const updateRequirementTemplateConfig = (templateId, field, value) => {
                const template = getRequirementTemplateById(templateId);
                if (!template) return;
                const nextConfig = applyRequirementConfigChange(template.config, field, value);
                setRequirementTemplates(prev => prev.map(item =>
                    item.id === templateId ? { ...item, config: nextConfig } : item
                ));
                syncTemplateToExecutions(templateId, nextConfig);
            };

            const applyTemplateToExecution = (executionId, templateId) => {
                if (!templateId) return;
                const templateConfig = ensureTemplateConfig(templateId);
                setTestCases(prev => prev.map(tc => {
                    if (tc.id !== activeTestCase) return tc;
                    return {
                        ...tc,
                        executions: tc.executions.map(ex =>
                            ex.id === executionId
                                ? {
                                    ...ex,
                                    requirementTemplateId: templateId,
                                    requirements: mergeExecutionRequirements(templateConfig)
                                }
                                : ex
                        )
                    };
                }));
            };

            const applyTemplateToAllExecutions = (templateId) => {
                if (!templateId) return;
                const templateConfig = ensureTemplateConfig(templateId);
                setTestCases(prev => prev.map(tc => {
                    if (tc.id !== activeTestCase) return tc;
                    return {
                        ...tc,
                        executions: tc.executions.map(ex => ({
                            ...ex,
                            requirementTemplateId: templateId,
                            requirements: mergeExecutionRequirements(templateConfig)
                        }))
                    };
                }));
            };

            const updateTestCaseTemplateSelection = (templateId) => {
                setTestCases(prev => prev.map(tc =>
                    tc.id === activeTestCase ? { ...tc, requirementTemplateId: templateId } : tc
                ));
            };

            const getRequirementConfigForTestCase = (testCase) => {
                if (!testCase) return null;
                const template = getRequirementTemplateById(testCase.requirementTemplateId);
                if (template) {
                    return mergeExecutionRequirements(template.config);
                }
                const firstExecution = testCase.executions?.[0];
                if (firstExecution) {
                    return mergeExecutionRequirements(firstExecution.requirements);
                }
                return null;
            };

            // Icons
            const Icon = ({ name }) => {
                const icons = {
                    'plus': 'â•', 'trash-2': 'ğŸ—‘ï¸', 'download': 'â¬‡ï¸', 'upload': 'â¬†ï¸',
                    'edit': 'âœï¸', 'save': 'ğŸ’¾', 'x': 'âŒ', 'check': 'âœ…',
                    'bar-chart': 'ğŸ“Š', 'settings': 'âš™ï¸', 'file-text': 'ğŸ“„',
                    'eye': 'ğŸ‘ï¸', 'eye-off': 'ğŸ‘ï¸â€ğŸ—¨ï¸', 'git-compare': 'ğŸ”„',
                    'hard-drive': 'ğŸ’½', 'star': 'â­', 'star-off': 'â˜†',
                    'alert-triangle': 'âš ï¸'
                };
                return <span>{icons[name] || 'â€¢'}</span>;
            };

            // Parse timecode with FPS defaulting
            const parseTimecode = (timecode, fps = 30) => {
                const parts = timecode.split(':');
                if (parts.length !== 4) return 0;

                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                const seconds = parseInt(parts[2]) || 0;
                const frames = parseInt(parts[3]) || 0;

                const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
                const frameTime = frames / fps;

                return (totalSeconds + frameTime) * 1000;
            };

            const msToSecondsFormat = (ms) => (ms / 1000).toFixed(3);
            const formatMsToTime = (ms) => (!ms && ms !== 0) ? '-' : (ms / 1000).toFixed(3) + 's';

            // Parse marker naming
            function parseMarkerName(markerName) {
                const yellowRegex = /AB(\d+)\s+(.+?)\s+Tag([\d.]+)\s*\(([XYZ])([+-])\)/i;
                const yellowMatch = markerName.match(yellowRegex);

                if (yellowMatch) {
                    return {
                        type: 'identifier',
                        abNumber: 'AB' + yellowMatch[1],
                        descriptor: yellowMatch[2],
                        tagVersion: yellowMatch[3],
                        axis: yellowMatch[4].toUpperCase(),
                        direction: yellowMatch[5]
                    };
                }

                // Action marker: TagOn #1, TagOn.Activation #1
                const actionRegex = /Tag(\w+)(?:\.(\w+))?\s+#(\d+)/i;
                const actionMatch = markerName.match(actionRegex);

                if (actionMatch) {
                    return {
                        type: 'action',
                        tagAction: actionMatch[1],
                        subAction: actionMatch[2] || '',
                        testRun: actionMatch[3]
                    };
                }

                // Error marker: Error-start #1, Error-end #1
                const errorRegex = /Error-(start|end)\s+#(\d+)/i;
                const errorMatch = markerName.match(errorRegex);

                if (errorMatch) {
                    return {
                        type: 'error',
                        errorType: errorMatch[1],
                        errorNumber: errorMatch[2]
                    };
                }

                return null;
            }

            // Parse CSV with FPS auto-detection
            const parseDavinciCSV = (csvText, filename) => {
                console.log('Parsing CSV: ' + filename);
                const lines = csvText.split('\n').filter(line => line.trim());
                if (lines.length < 2) return null;

                const parseCSVLine = (line) => {
                    const result = [];
                    let current = '';
                    let inQuotes = false;

                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    result.push(current.trim());
                    return result;
                };

                // Parse all data rows
                const dataRows = [];
                let detectedFPS = 30; // Default FPS

                for (let i = 1; i < lines.length; i++) {
                    const row = parseCSVLine(lines[i]);
                    if (row.length > 20) {
                        const rowFPS = parseFloat(row[17]);
                        if (rowFPS > 0 && rowFPS !== detectedFPS) {
                            detectedFPS = rowFPS;
                        }
                        dataRows.push({
                            recordIn: row[9] || '',
                            color: row[19] || '',
                            notes: row[20] || ''
                        });
                    }
                }

                console.log('Detected FPS: ' + detectedFPS);

                const timestamps = [];
                const pendingMarkers = {};
                const errorGroups = {};
                let currentMetadata = {};
                const axesFound = new Set();
                const rangesDetected = {};

                dataRows.forEach((row, index) => {
                    const color = row.color.toLowerCase();
                    const notes = row.notes;
                    const timeMs = parseTimecode(row.recordIn, detectedFPS);
                    const timeStr = msToSecondsFormat(timeMs);

                    // Skip blue markers (placeholders)
                    if (color === 'blue') return;

                    // Current axis context
                    const currentAxis = currentMetadata?.axis || '';
                    const currentDirection = currentMetadata?.direction || '';

                    // Handle red markers (error zones) with grouping
                    if (color === 'red') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'error') {
                            const errorNum = parsed.errorNumber;

                            if (!errorGroups[errorNum]) {
                                errorGroups[errorNum] = { start: null, end: null };
                            }

                            if (parsed.errorType === 'start') {
                                errorGroups[errorNum].start = {
                                    time: timeStr,
                                    recordIn: row.recordIn,
                                    timeMs: timeMs
                                };
                            } else {
                                errorGroups[errorNum].end = {
                                    time: timeStr,
                                    recordIn: row.recordIn,
                                    timeMs: timeMs
                                };
                            }

                            if (errorGroups[errorNum].start && errorGroups[errorNum].end) {
                                const start = errorGroups[errorNum].start;
                                const end = errorGroups[errorNum].end;
                                const duration = end.timeMs - start.timeMs;

                                timestamps.push({
                                    id: Date.now().toString() + Math.random(),
                                    time: start.time,
                                    recordIn: start.recordIn,
                                    label: 'Error',
                                    note: 'Error #' + errorNum + ' (Duration: ' + msToSecondsFormat(duration) + 's)',
                                    userNotes: '',
                                    stage: '',
                                    axis: currentAxis,
                                    direction: currentDirection,
                                    latencyMs: null,
                                    excludeFromStats: true,
                                    isError: true,
                                    isMarked: false,
                                    errorNumber: errorNum,
                                    errorDuration: duration
                                });
                            }
                        }
                        return;
                    }

                    // Handle yellow markers (axis identifiers)
                    if (color === 'yellow') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'identifier') {
                            currentMetadata = parsed;
                            const axisKey = parsed.axis + parsed.direction;
                            axesFound.add(axisKey);

                            const rangeMatch = notes.match(/(\d+)\s*mm/i);
                            rangesDetected[axisKey] = rangeMatch ? parseInt(rangeMatch[1]) : null;
                        }
                    }
                    // Green markers (TagOn trigger)
                    else if (color === 'green') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'action') {
                            const key = 'tagOn-' + parsed.testRun;
                            pendingMarkers[key] = {
                                time: timeStr,
                                recordIn: row.recordIn,
                                timeMs: timeMs,
                                testRun: parsed.testRun,
                                notes: notes,
                                metadata: currentMetadata
                            };
                        }
                    }
                    // Handle pink markers (TagOn activation)
                    else if (color === 'pink') {
                        const tagOnKeys = Object.keys(pendingMarkers).filter(k => k.startsWith('tagOn-'));
                        if (tagOnKeys.length > 0) {
                            const lastKey = tagOnKeys[tagOnKeys.length - 1];
                            const tagOnMarker = pendingMarkers[lastKey];
                            delete pendingMarkers[lastKey];

                            const latency = timeMs - tagOnMarker.timeMs;

                            timestamps.push({
                                id: Date.now().toString() + Math.random(),
                                time: tagOnMarker.time,
                                recordIn: tagOnMarker.recordIn,
                                label: 'TagOn',
                                note: tagOnMarker.notes + ' â†’ ' + notes,
                                userNotes: '',
                                stage: 'Tag' + (tagOnMarker.metadata?.tagVersion || '1.0') + ' Run#' + tagOnMarker.testRun,
                                pairedTime: timeStr,
                                pairedRecordIn: row.recordIn,
                                latency: msToSecondsFormat(latency),
                                latencyMs: latency,
                                axis: tagOnMarker.metadata?.axis || '',
                                direction: tagOnMarker.metadata?.direction || '',
                                abNumber: tagOnMarker.metadata?.abNumber || '',
                                tagVersion: tagOnMarker.metadata?.tagVersion || '',
                                testRun: tagOnMarker.testRun,
                                excludeFromStats: false,
                                calculationExplained: tagOnMarker.recordIn + ' â†’ ' + row.recordIn + ' = ' + msToSecondsFormat(latency),
                                isError: false,
                                isMarked: false
                            });
                        }
                    }
                    // Handle cyan markers (TagOff trigger)
                    else if (color === 'cyan') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'action') {
                            const key = 'tagOff-' + parsed.testRun;
                            pendingMarkers[key] = {
                                time: timeStr,
                                recordIn: row.recordIn,
                                timeMs: timeMs,
                                testRun: parsed.testRun,
                                notes: notes,
                                metadata: currentMetadata
                            };
                        }
                    }
                    // Handle lemon/lime markers (TagOff activation)
                    else if (color === 'lemon' || color === 'lime') {
                        const tagOffKeys = Object.keys(pendingMarkers).filter(k => k.startsWith('tagOff-'));
                        if (tagOffKeys.length > 0) {
                            const lastKey = tagOffKeys[tagOffKeys.length - 1];
                            const tagOffMarker = pendingMarkers[lastKey];
                            delete pendingMarkers[lastKey];

                            const latency = timeMs - tagOffMarker.timeMs;

                            timestamps.push({
                                id: Date.now().toString() + Math.random(),
                                time: tagOffMarker.time,
                                recordIn: tagOffMarker.recordIn,
                                label: 'TagOff',
                                note: tagOffMarker.notes + ' â†’ ' + notes,
                                userNotes: '',
                                stage: 'Tag' + (tagOffMarker.metadata?.tagVersion || '1.0') + ' Run#' + tagOffMarker.testRun,
                                pairedTime: timeStr,
                                pairedRecordIn: row.recordIn,
                                latency: msToSecondsFormat(latency),
                                latencyMs: latency,
                                axis: tagOffMarker.metadata?.axis || '',
                                direction: tagOffMarker.metadata?.direction || '',
                                abNumber: tagOffMarker.metadata?.abNumber || '',
                                tagVersion: tagOffMarker.metadata?.tagVersion || '',
                                testRun: tagOffMarker.testRun,
                                excludeFromStats: false,
                                calculationExplained: tagOffMarker.recordIn + ' â†’ ' + row.recordIn + ' = ' + msToSecondsFormat(latency),
                                isError: false,
                                isMarked: false
                            });
                        }
                    }
                });

                // Handle unmatched markers
                Object.values(pendingMarkers).forEach(marker => {
                    timestamps.push({
                        id: Date.now().toString() + Math.random(),
                        time: marker.time,
                        recordIn: marker.recordIn,
                        label: 'Error',
                        note: marker.notes + ' (UNMATCHED)',
                        userNotes: '',
                        stage: '',
                        axis: marker.metadata?.axis || '',
                        direction: marker.metadata?.direction || '',
                        latencyMs: null,
                        excludeFromStats: true,
                        isError: true,
                        isMarked: false
                    });
                });

                console.log('Parsed timestamps: ' + timestamps.length);
                console.log('Axes found: ' + Array.from(axesFound).join(', '));

                return {
                    timestamps,
                    metadata: currentMetadata,
                    axesFound: Array.from(axesFound),
                    rangesDetected,
                    filename,
                    fps: detectedFPS
                };
            };

            const hydrateTestCases = (cases = [], templates = requirementTemplates) => {
                return cases.map(tc => {
                    const templateId = tc.requirementTemplateId || templates[0]?.id || null;
                    return {
                        ...tc,
                        requirementTemplateId: templateId,
                        environment: { ...getDefaultEnvironment(), ...(tc.environment || {}) },
                        distances: normalizeDistances(tc.distances || {}),
                        executions: (tc.executions || []).map(execution => ({
                            ...execution,
                            timestamps: (execution.timestamps || []).map(ts => ({
                                ...ts,
                                note: ts.note || '',
                                isMarked: Boolean(ts.isMarked)
                            })),
                            requirements: mergeExecutionRequirements(execution.requirements),
                            requirementTemplateId: execution.requirementTemplateId || templateId,
                            hardware: normalizeHardwareList(execution.hardware || []),
                            notes: execution.notes || ''
                        }))
                    };
                });
            };

            // Statistics
            function getStatistics(timestamps, requirements = null) {
                const validTimestamps = timestamps.filter(ts =>
                    ts.latencyMs != null && !ts.excludeFromStats && !ts.isError
                );

                if (validTimestamps.length === 0) {
                    return { min: 0, max: 0, avg: 0, total: 0, passed: 0, failed: 0, passRate: 0 };
                }

                const values = validTimestamps.map(ts => ts.latencyMs);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;

                let passed = 0;
                let failed = 0;

                if (requirements && requirements.enabled) {
                    validTimestamps.forEach(ts => {
                        if (ts.latencyMs <= requirements.maxLatency) {
                            passed++;
                        } else {
                            failed++;
                        }
                    });
                }

                const passRate = validTimestamps.length > 0 ? (passed / validTimestamps.length) * 100 : 0;

                return { min, max, avg, total: validTimestamps.length, passed, failed, passRate };
            }

            function getAxisStatistics(timestamps, axis, direction, requirements = null) {
                const axisTimestamps = timestamps.filter(ts =>
                    ts.axis === axis && ts.direction === direction && !ts.isError
                );

                const validTimestamps = axisTimestamps.filter(ts =>
                    ts.latencyMs != null && !ts.excludeFromStats
                );

                if (validTimestamps.length === 0) {
                    return {
                        min: 0,
                        max: 0,
                        avg: 0,
                        total: 0,
                        passed: 0,
                        failed: 0,
                        passRate: 0,
                        errorCount: axisTimestamps.filter(ts => ts.isError).length
                    };
                }

                const values = validTimestamps.map(ts => ts.latencyMs);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;

                let passed = 0;
                let failed = 0;

                if (requirements && requirements.enabled) {
                    validTimestamps.forEach(ts => {
                        if (ts.latencyMs <= requirements.maxLatency) {
                            passed++;
                        } else {
                            failed++;
                        }
                    });
                }

                const passRate = validTimestamps.length > 0 ? (passed / validTimestamps.length) * 100 : 0;
                const errorCount = axisTimestamps.filter(ts => ts.isError).length;

                return { min, max, avg, total: validTimestamps.length, passed, failed, passRate, errorCount };
            }

            const UNGROUPED_BUCKET = 'Ungrouped';

            // Group by axis
            const groupByAxis = (timestamps) => {
                const groups = {};
                const insertionOrder = [];
                const ungrouped = [];

                timestamps.forEach(ts => {
                    if (ts.isError) return;

                    if (ts.axis && ts.direction) {
                        const key = ts.axis + ts.direction;
                        if (!groups[key]) {
                            groups[key] = [];
                            insertionOrder.push(key);
                        }
                        groups[key].push(ts);
                    } else {
                        ungrouped.push(ts);
                    }
                });

                const orderedGroups = {};
                insertionOrder.forEach(key => {
                    orderedGroups[key] = groups[key];
                });

                if (ungrouped.length > 0) {
                    orderedGroups[UNGROUPED_BUCKET] = ungrouped;
                }

                return orderedGroups;
            };

            // Create new execution
            const createNewExecution = (testCase = { executions: [] }, templateConfig = null, templateId = null) => ({
                id: Date.now().toString() + '_exec',
                name: 'Execution ' + ((testCase?.executions?.length || 0) + 1),
                timestamps: [],
                requirements: mergeExecutionRequirements(templateConfig || getDefaultExecutionRequirements()),
                requirementTemplateId: templateId,
                notes: '',
                hardware: []
            });

            // Create new test case
            const createNewTestCase = () => {
                const defaultTemplateId = requirementTemplates[0]?.id || null;
                const defaultTemplateConfig = ensureTemplateConfig(defaultTemplateId);
                const testCase = {
                    id: Date.now().toString(),
                    name: 'Test Case ' + (testCases.length + 1),
                    metadata: {},
                    distances: {}, // Manual distance input per axis
                    environment: getDefaultEnvironment(),
                    executions: [],
                    requirementTemplateId: defaultTemplateId
                };
                const initialExecution = createNewExecution(testCase, defaultTemplateConfig, defaultTemplateId);
                testCase.executions.push(initialExecution);
                return testCase;
            };

            const openImportWizardForCsv = (fileName, parsedResult) => {
                if (!parsedResult || parsedResult.timestamps.length === 0) return;

                const baseName = fileName.replace(/\.csv$/i, '');
                const defaultTarget = testCases.length === 0
                    ? 'new'
                    : (activeTestCase || (testCases[0]?.id ?? 'new'));
                const selectedTc = testCases.find(tc => tc.id === defaultTarget);

                const newCaseEnvironment = {
                    ...getDefaultEnvironment(),
                    name: parsedResult.metadata?.descriptor || '',
                    dut: parsedResult.metadata?.abNumber || '',
                    notes: parsedResult.metadata?.tagVersion
                        ? `Tag version ${parsedResult.metadata.tagVersion}`
                        : ''
                };

                const suggestedEnvironment = selectedTc
                    ? { ...getDefaultEnvironment(), ...(selectedTc.environment || {}) }
                    : newCaseEnvironment;

                const defaultHardware = {
                    ...createHardwareItem(),
                    type: 'DUT',
                    name: parsedResult.metadata?.descriptor || '',
                    serialNumber: parsedResult.metadata?.abNumber || '',
                    version: parsedResult.metadata?.tagVersion || ''
                };

                setImportDialog({
                    fileName,
                    parsed: parsedResult,
                    targetTestCaseId: defaultTarget,
                    newCaseDefaults: {
                        testCaseName: baseName,
                        environment: newCaseEnvironment,
                        hardware: [defaultHardware]
                    },
                    form: {
                        testCaseName: selectedTc ? selectedTc.name : baseName,
                        environment: suggestedEnvironment,
                        executionName: baseName,
                        executionNotes: '',
                        hardware: [defaultHardware]
                    }
                });
            };

            // Import file
            const handleFileImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const content = event.target.result;

                    if (file.name.toLowerCase().endsWith('.csv')) {
                        try {
                            const result = parseDavinciCSV(content, file.name);
                            if (result && result.timestamps.length > 0) {
                                openImportWizardForCsv(file.name, result);
                            } else {
                                alert('No timestamps were detected in this CSV.');
                            }
                        } catch (err) {
                            alert('Error importing CSV: ' + err.message);
                            console.error(err);
                        }
                    } else if (file.name.toLowerCase().endsWith('.json')) {
                        try {
                            const data = JSON.parse(content);
                            let importedTemplates = requirementTemplates;
                            if (Array.isArray(data.requirementTemplates)) {
                                importedTemplates = data.requirementTemplates.map(template =>
                                    createRequirementTemplate(template)
                                );
                                setRequirementTemplates(importedTemplates);
                            } else if (data.globalRequirements) {
                                const legacyTemplate = createRequirementTemplate({
                                    name: 'Imported Requirements',
                                    config: convertLegacyRequirementsToConfig(data.globalRequirements)
                                });
                                importedTemplates = [legacyTemplate];
                                setRequirementTemplates(importedTemplates);
                            }
                            if (data.testCases) {
                                setTestCases(hydrateTestCases(data.testCases, importedTemplates));
                            }
                            if (Array.isArray(data.defects)) {
                                setDefects(data.defects.map(defect => createDefectRecord(defect)));
                            }
                            alert('Data imported successfully!');
                        } catch (err) {
                            alert('Error importing JSON: ' + err.message);
                        }
                    }
                };

                reader.readAsText(file);
                e.target.value = '';
            };

            // Export to JSON
            const handleExportJSON = () => {
                const data = {
                    testCases,
                    requirementTemplates,
                    defects,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'latency-test-data-' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
                URL.revokeObjectURL(url);
            };

            const updateImportTarget = (value) => {
                setImportDialog(prev => {
                    if (!prev) return prev;
                    let nextForm = { ...prev.form };
                    if (value === 'new') {
                        nextForm.testCaseName = prev.newCaseDefaults?.testCaseName || nextForm.testCaseName;
                        nextForm.environment = {
                            ...getDefaultEnvironment(),
                            ...(prev.newCaseDefaults?.environment || {})
                        };
                    } else {
                        const tc = testCases.find(item => item.id === value);
                        if (tc) {
                            nextForm.testCaseName = tc.name;
                            nextForm.environment = {
                                ...getDefaultEnvironment(),
                                ...(tc.environment || {})
                            };
                        }
                    }

                    return { ...prev, targetTestCaseId: value, form: nextForm };
                });
            };

            const updateImportFormField = (field, value) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        [field]: value
                    }
                }) : prev);
            };

            const updateImportEnvironmentField = (field, value) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        environment: {
                            ...prev.form.environment,
                            [field]: value
                        }
                    }
                }) : prev);
            };

            const updateImportHardwareField = (hardwareId, field, value) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: prev.form.hardware.map(hw =>
                            hw.id === hardwareId ? { ...hw, [field]: value } : hw
                        )
                    }
                }) : prev);
            };

            const addHardwareToImport = () => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: [...prev.form.hardware, createHardwareItem()]
                    }
                }) : prev);
            };

            const removeHardwareFromImport = (hardwareId) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: prev.form.hardware.filter(hw => hw.id !== hardwareId)
                    }
                }) : prev);
            };

            const addDefect = () => {
                setDefects(prev => [...prev, createDefectRecord()]);
            };

            const updateDefectField = (defectId, field, value) => {
                setDefects(prev => prev.map(defect =>
                    defect.id === defectId
                        ? { ...defect, [field]: value, lastUpdated: new Date().toISOString() }
                        : defect
                ));
            };

            const deleteDefect = (defectId) => {
                setDefects(prev => prev.filter(defect => defect.id !== defectId));
            };

            const exportDefectsDocument = () => {
                const payload = {
                    release: 'v3.9 RC',
                    lastUpdated: new Date().toISOString(),
                    defects
                };
                const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'v3.9-rc-defects.json';
                a.click();
                URL.revokeObjectURL(url);
            };

            const closeImportDialog = () => setImportDialog(null);

            const applyRangesToDistances = (baseDistances = {}, rangesDetected = {}) => {
                const updated = { ...baseDistances };
                Object.entries(rangesDetected).forEach(([axisKey, distance]) => {
                    if (distance === null || distance === undefined) return;
                    const axis = axisKey?.[0];
                    if (!axis) return;
                    if (!updated[axis] || distance > updated[axis]) {
                        updated[axis] = distance;
                    }
                });
                return updated;
            };

            const finalizeImportDialog = () => {
                if (!importDialog) return;

                const { parsed, form, targetTestCaseId } = importDialog;
                let updatedTestCases = [...testCases];
                let targetTestCase = null;

                if (targetTestCaseId === 'new') {
                    targetTestCase = createNewTestCase();
                    targetTestCase.executions = [];
                    targetTestCase.name = form.testCaseName || targetTestCase.name;
                    targetTestCase.environment = { ...getDefaultEnvironment(), ...(form.environment || {}) };
                    targetTestCase.metadata = parsed.metadata || {};
                    updatedTestCases.push(targetTestCase);
                } else {
                    updatedTestCases = testCases.map(tc => {
                        if (tc.id === targetTestCaseId) {
                            const next = {
                                ...tc,
                                name: form.testCaseName || tc.name,
                                environment: { ...getDefaultEnvironment(), ...(form.environment || {}) },
                                metadata: { ...tc.metadata, ...(parsed.metadata || {}) }
                            };
                            targetTestCase = next;
                            return next;
                        }
                        return tc;
                    });
                }

                if (!targetTestCase) {
                    alert('Unable to locate target test case for import.');
                    return;
                }

                const templateId = targetTestCase.requirementTemplateId;
                const templateConfig = ensureTemplateConfig(templateId);
                const execution = createNewExecution(targetTestCase, templateConfig, templateId);
                execution.name = form.executionName || importDialog.fileName;
                execution.timestamps = parsed.timestamps;
                execution.fps = parsed.fps;
                execution.notes = form.executionNotes;
                const sanitizedHardware = (form.hardware || [])
                    .map(hw => ({ ...hw, id: hw.id || (Date.now().toString() + Math.random()) }))
                    .filter(hw => (hw.type || hw.name || hw.serialNumber || hw.version || hw.revision || hw.notes));
                execution.hardware = sanitizedHardware;

                targetTestCase.executions = [...(targetTestCase.executions || []), execution];
                targetTestCase.distances = applyRangesToDistances(targetTestCase.distances || {}, parsed.rangesDetected || {});
                targetTestCase.metadata = { ...targetTestCase.metadata, ...(parsed.metadata || {}) };

                setTestCases(updatedTestCases);
                setActiveTestCase(targetTestCase.id);
                setActiveExecution(execution.id);

                alert('CSV imported successfully!\n' +
                    'FPS: ' + parsed.fps + '\n' +
                    'Timestamps: ' + parsed.timestamps.length + '\n' +
                    'Axes: ' + parsed.axesFound.join(', '));

                setImportDialog(null);
            };

            const getDistanceForAxisKey = (testCase, axisKey) => {
                if (!testCase) return null;
                const axis = axisKey?.[0];
                if (!axis) return null;
                const template = getRequirementTemplateById(testCase.requirementTemplateId);
                const templateValue = template?.config?.mustNotRespondRanges?.[axis];
                if (templateValue || templateValue === 0) {
                    return templateValue;
                }
                if (testCase?.distances?.[axisKey] || testCase?.distances?.[axisKey] === 0) {
                    return testCase.distances[axisKey];
                }
                if (testCase?.distances?.[axis] || testCase?.distances?.[axis] === 0) {
                    return testCase.distances[axis];
                }
                return null;
            };

            const updateTestCaseEnvironmentField = (field, value) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            environment: {
                                ...getDefaultEnvironment(),
                                ...(tc.environment || {}),
                                [field]: value
                            }
                        };
                    }
                    return tc;
                }));
            };

            const updateExecutionField = (executionId, field, value) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex =>
                                ex.id === executionId ? { ...ex, [field]: value } : ex
                            )
                        };
                    }
                    return tc;
                }));
            };

            const addHardwareToExecution = () => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex =>
                                ex.id === activeExecution
                                    ? { ...ex, hardware: [...(ex.hardware || []), createHardwareItem()] }
                                    : ex
                            )
                        };
                    }
                    return tc;
                }));
            };

            const updateExecutionHardwareField = (hardwareId, field, value) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        hardware: (ex.hardware || []).map(hw =>
                                            hw.id === hardwareId ? { ...hw, [field]: value } : hw
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                }));
            };

            const removeExecutionHardware = (hardwareId) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex =>
                                ex.id === activeExecution
                                    ? { ...ex, hardware: (ex.hardware || []).filter(hw => hw.id !== hardwareId) }
                                    : ex
                            )
                        };
                    }
                    return tc;
                }));
            };

            const deleteExecution = (executionId, targetTestCaseId = activeTestCase) => {
                const tc = testCases.find(item => item.id === targetTestCaseId);
                if (!tc) return;
                if (tc.executions.length === 1) {
                    alert('A test case must have at least one execution. Add another before deleting this one.');
                    return;
                }
                if (!confirm('Delete this execution? This cannot be undone.')) return;

                const updatedExecutions = tc.executions.filter(ex => ex.id !== executionId);
                const updatedTestCases = testCases.map(item =>
                    item.id === tc.id ? { ...item, executions: updatedExecutions } : item
                );
                setTestCases(updatedTestCases);

                if (targetTestCaseId === activeTestCase) {
                    setActiveExecution(updatedExecutions[0]?.id || null);
                }
            };

            // Toggle marker inclusion
            const toggleMarkerInclusion = (timestampId) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts => {
                                            if (ts.id === timestampId) {
                                                return { ...ts, excludeFromStats: !ts.excludeFromStats };
                                            }
                                            return ts;
                                        })
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            // Update axis/direction assignments
            const updateTimestampAxisDirection = (timestampId, newAxis, newDirection) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts =>
                                            ts.id === timestampId
                                                ? { ...ts, axis: newAxis, direction: newDirection }
                                                : ts
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const updateTimestampNote = (timestampId, newNote) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts =>
                                            ts.id === timestampId ? { ...ts, note: newNote } : ts
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const toggleTimestampMark = (timestampId) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts =>
                                            ts.id === timestampId ? { ...ts, isMarked: !ts.isMarked } : ts
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const handleEditTimestampNote = (timestampId, currentNote = '') => {
                const note = prompt('Add a note for this latency measurement:', currentNote || '');
                if (note === null) return;
                updateTimestampNote(timestampId, note);
            };

            // Delete timestamp
            const handleDeleteTimestamp = (timestampId) => {
                if (!confirm('Delete this entry?')) return;

                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.filter(ts => ts.id !== timestampId)
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const addToComparison = (testCaseId, executionId, axisKey = null) => {
                const targetTestCase = testCases.find(tc => tc.id === testCaseId);
                const targetExecution = targetTestCase?.executions.find(ex => ex.id === executionId);
                if (!targetTestCase || !targetExecution) return;

                const hasComparableSamples = targetExecution.timestamps.some(ts => {
                    if (ts.isError || ts.latencyMs == null || ts.excludeFromStats) return false;
                    if (!axisKey) return true;
                    if (!ts.axis || !ts.direction) return false;
                    return (ts.axis + ts.direction) === axisKey;
                });

                if (!hasComparableSamples) {
                    alert(axisKey ? 'No comparable measurements for this axis were found.' : 'No comparable measurements found for this execution.');
                    return;
                }

                const entryKey = `${testCaseId}-${executionId}-${axisKey || 'execution'}`;

                setComparisonExecutions(prev => {
                    if (prev.some(entry => entry.key === entryKey)) {
                        return prev;
                    }
                    return [...prev, { key: entryKey, testCaseId, executionId, axisKey }];
                });

                setView('comparison');
            };

            const removeFromComparison = (entryKey) => {
                setComparisonExecutions(prev => prev.filter(entry => entry.key !== entryKey));
            };

            // Update test case name
            const updateTestCaseName = (testCaseId, newName) => {
                const updated = testCases.map(tc =>
                    tc.id === testCaseId ? { ...tc, name: newName } : tc
                );
                setTestCases(updated);
            };

            // Delete test case
            const deleteTestCase = (testCaseId) => {
                if (!confirm('Delete this test case? This cannot be undone.')) return;

                const updated = testCases.filter(tc => tc.id !== testCaseId);
                setTestCases(updated);

                if (activeTestCase === testCaseId) {
                    setActiveTestCase(updated.length > 0 ? updated[0].id : null);
                    setActiveExecution(updated.length > 0 && updated[0].executions.length > 0 ? updated[0].executions[0].id : null);
                }
            };

            

            const updateExecutionRequirements = (field, value) => {
                if (!activeTestCase || !activeExecution) return;

                const updated = testCases.map(tc => {
                    if (tc.id !== activeTestCase) return tc;

                    return {
                        ...tc,
                        executions: tc.executions.map(ex => {
                            if (ex.id !== activeExecution) return ex;

                            const nextRequirements = applyRequirementConfigChange(ex.requirements, field, value);

                            return {
                                ...ex,
                                requirementTemplateId: null,
                                requirements: nextRequirements
                            };
                        })
                    };
                });

                setTestCases(updated);
            };

            // Get current test case and execution
            const currentTestCase = testCases.find(tc => tc.id === activeTestCase);
            const currentExecution = currentTestCase?.executions.find(ex => ex.id === activeExecution);
            const currentExecutionHasComparableSamples = currentExecution?.timestamps?.some(ts =>
                !ts.isError && ts.latencyMs != null && !ts.excludeFromStats
            );

            // Requirements Settings View
            const renderRequirementsView = () => (
                <div className="p-6 max-w-5xl space-y-6">
                    <div className="flex items-center justify-between">
                        <h2 className="text-2xl font-bold">Requirement Templates</h2>
                        <button
                            onClick={addRequirementTemplate}
                            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                        >
                            <Icon name="plus" /> Add Template
                        </button>
                    </div>

                    {requirementTemplates.length === 0 ? (
                        <div className="bg-yellow-50 border border-yellow-200 text-yellow-800 p-4 rounded">
                            <p className="text-sm">No templates available. Create one using the button above.</p>
                        </div>
                    ) : (
                        requirementTemplates.map(template => (
                            <div key={template.id} className="bg-white rounded-lg shadow p-6 space-y-4">
                                <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                                    <input
                                        type="text"
                                        value={template.name}
                                        onChange={(e) => updateRequirementTemplateDetails(template.id, 'name', e.target.value)}
                                        className="text-lg font-semibold border rounded px-3 py-2 flex-1"
                                    />
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => deleteRequirementTemplate(template.id)}
                                            className="px-3 py-1.5 text-sm text-red-600 border border-red-200 rounded hover:bg-red-50"
                                            disabled={requirementTemplates.length <= 1}
                                        >
                                            <Icon name="trash-2" /> Delete
                                        </button>
                                    </div>
                                </div>
                                <textarea
                                    value={template.description}
                                    onChange={(e) => updateRequirementTemplateDetails(template.id, 'description', e.target.value)}
                                    className="w-full border rounded px-3 py-2 text-sm"
                                    rows="2"
                                    placeholder="Describe where to use this template"
                                ></textarea>
                                <div className="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        className="w-4 h-4"
                                        checked={template.config.enabled}
                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'enabled', e.target.checked)}
                                    />
                                    <span className="text-sm">Enable requirements when this template is applied</span>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Maximum Latency (ms)</label>
                                    <input
                                        type="number"
                                        value={template.config.maxLatency}
                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'maxLatency', parseFloat(e.target.value) || 100)}
                                        className="w-40 px-3 py-2 border rounded"
                                    />
                                </div>
                                <div>
                                    <h4 className="text-sm font-semibold mb-3">Range Requirements (mm)</h4>
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {AXES.map(axis => (
                                            <div key={axis} className="border rounded p-3 space-y-2">
                                                <div className="font-medium">{axis} Axis</div>
                                                <div>
                                                    <label className="block text-xs mb-1">Min Must Respond</label>
                                                    <input
                                                        type="number"
                                                        value={template.config.minRespondRanges[axis]}
                                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'minRespondRanges', {
                                                            ...template.config.minRespondRanges,
                                                            [axis]: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs mb-1">Must NOT Respond</label>
                                                    <input
                                                        type="number"
                                                        value={template.config.mustNotRespondRanges[axis]}
                                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'mustNotRespondRanges', {
                                                            ...template.config.mustNotRespondRanges,
                                                            [axis]: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        ))
                    )}

                    <div>
                        <button
                            onClick={() => setView('execution')}
                            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                        >
                            Back to Execution View
                        </button>
                    </div>
                </div>
            );

            // Test Report View
            const renderReportView = () => {
                const selectedTests = testCases.filter(tc =>
                    selectedForReport.includes(tc.id)
                );

                return (
                    <div className="p-6">
                        <div className="no-print mb-6 flex justify-between items-center">
                            <h2 className="text-2xl font-bold">Test Report</h2>
                            <div className="space-x-2">
                                <button
                                    onClick={() => window.print()}
                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                >
                                    <Icon name="download" /> Print/Export PDF
                                </button>
                                <button
                                    onClick={() => setView('execution')}
                                    className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
                                >
                                    Back
                                </button>
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow p-6">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold mb-2">Hardware Latency Test Report</h1>
                                <p className="text-gray-600">Generated: {new Date().toLocaleString()}</p>
                            </div>

                            {selectedTests.length === 0 ? (
                                <div className="text-center py-12 text-gray-500">
                                    <p>No test cases selected for report.</p>
                                    <p className="text-sm mt-2">Select test cases in the execution view to include them in the report.</p>
                                </div>
                            ) : (
                                selectedTests.map(tc => {
                                    const allTimestamps = tc.executions.flatMap(ex => ex.timestamps);
                                    const overallStats = getStatistics(allTimestamps);
                                    const axisList = [...new Set(allTimestamps
                                        .filter(ts => ts.axis && ts.direction)
                                        .map(ts => ts.axis + ts.direction)
                                    )];
                                    const axisGroups = groupByAxis(allTimestamps);
                                    const reportRequirements = getRequirementConfigForTestCase(tc);

                                    return (
                                        <div key={tc.id} className="mb-12 page-break-after">
                                            <h2 className="text-2xl font-bold mb-4 border-b pb-2">{tc.name}</h2>

                                            {/* Test Information */}
                                            <div className="mb-6">
                                                <h3 className="text-lg font-semibold mb-2">Test Information</h3>
                                                <div className="grid grid-cols-2 gap-4 text-sm">
                                                    <div>
                                                        <span className="font-medium">AB Number:</span> {tc.metadata.abNumber || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Tag Version:</span> {tc.metadata.tagVersion || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Total Executions:</span> {tc.executions.length}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Total Measurements:</span> {allTimestamps.filter(ts => !ts.isError).length}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Environment:</span> {tc.environment?.name || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Location:</span> {tc.environment?.location || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Owner:</span> {tc.environment?.owner || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Primary DUT:</span> {tc.environment?.dut || 'N/A'}
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Tested Distances */}
                                            {tc.distances && Object.keys(tc.distances).length > 0 && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Tested Distances</h3>
                                                    <div className="flex flex-wrap gap-2">
                                                        {Object.entries(tc.distances)
                                                            .filter(([, distance]) => distance || distance === 0)
                                                            .map(([axis, distance]) => (
                                                                <span key={axis} className="px-3 py-1 bg-blue-100 rounded">
                                                                    {axis}: {distance}mm
                                                                </span>
                                                            ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* Overall Statistics */}
                                            <div className="mb-6">
                                                <h3 className="text-lg font-semibold mb-2">Overall Statistics</h3>
                                                <div className="grid grid-cols-4 gap-4 text-center">
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-green-600">
                                                            {formatMsToTime(overallStats.min)}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Minimum</div>
                                                    </div>
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-blue-600">
                                                            {formatMsToTime(overallStats.avg)}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Average</div>
                                                    </div>
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-red-600">
                                                            {formatMsToTime(overallStats.max)}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Maximum</div>
                                                    </div>
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-gray-600">
                                                            {overallStats.total}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Count</div>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Per-Axis Breakdown */}
                                            <div className="mb-6">
                                                <h3 className="text-lg font-semibold mb-2">Per-Axis Breakdown</h3>
                                                <table className="w-full text-sm">
                                                    <thead className="bg-gray-50">
                                                        <tr>
                                                            <th className="px-4 py-2 text-left">Axis</th>
                                                            <th className="px-4 py-2 text-right">Min</th>
                                                            <th className="px-4 py-2 text-right">Avg</th>
                                                            <th className="px-4 py-2 text-right">Max</th>
                                                            <th className="px-4 py-2 text-right">Count</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {axisList.map(axisKey => {
                                                            const axis = axisKey[0];
                                                            const direction = axisKey[1];
                                                            const stats = getAxisStatistics(allTimestamps, axis, direction, reportRequirements);

                                                            return (
                                                                <tr key={axisKey} className="border-t">
                                                                    <td className="px-4 py-2 font-medium">{axisKey}</td>
                                                                    <td className="px-4 py-2 text-right">{formatMsToTime(stats.min)}</td>
                                                                    <td className="px-4 py-2 text-right">{formatMsToTime(stats.avg)}</td>
                                                                    <td className="px-4 py-2 text-right">{formatMsToTime(stats.max)}</td>
                                                                    <td className="px-4 py-2 text-right">{stats.total}</td>
                                                                </tr>
                                                            );
                                                        })}
                                                    </tbody>
                                                </table>
                                            </div>

                                            {/* Requirements Check */}
                                            {reportRequirements?.enabled && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Requirements Check</h3>
                                                    <div className="text-sm">
                                                        <p><span className="font-medium">Maximum Latency:</span> {reportRequirements.maxLatency}ms</p>
                                                        <p className="mt-2">
                                                            <span className={overallStats.max <= reportRequirements.maxLatency ? 'text-green-600 font-bold' : 'text-red-600 font-bold'}>
                                                                {overallStats.max <= reportRequirements.maxLatency ? 'âœ… PASS' : 'âŒ FAIL'}
                                                            </span>
                                                        </p>
                                                    </div>
                                                </div>
                                            )}

                                            {Object.keys(axisGroups).length > 0 && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-4">Axis Execution Details</h3>
                                                    <div className="space-y-6">
                                                        {Object.entries(axisGroups).map(([axisKey, axisTimestamps]) => {
                                                            const isUngrouped = axisKey === UNGROUPED_BUCKET;
                                                            const axis = isUngrouped ? null : axisKey[0];
                                                            const direction = isUngrouped ? null : axisKey[1];
                                                            const axisStats = !isUngrouped
                                                                ? getAxisStatistics(allTimestamps, axis, direction, reportRequirements)
                                                                : getStatistics(axisTimestamps, reportRequirements);
                                                            const axisDistance = !isUngrouped ? getDistanceForAxisKey(tc, axisKey) : null;
                                                            const requirementRange = (!isUngrouped && reportRequirements)
                                                                ? {
                                                                    minRespond: reportRequirements.minRespondRanges?.[axis],
                                                                    mustNotRespond: reportRequirements.mustNotRespondRanges?.[axis]
                                                                }
                                                                : null;
                                                            const axisErrorCount = allTimestamps.filter(ts => {
                                                                if (isUngrouped) {
                                                                    return (!ts.axis || !ts.direction) && ts.isError;
                                                                }
                                                                return ts.axis === axis && ts.direction === direction && ts.isError;
                                                            }).length;

                                                            const requirementsEnabled = reportRequirements?.enabled && !isUngrouped;
                                                            let verdictLabel = 'Not evaluated';
                                                            let verdictClass = 'text-gray-500';
                                                            if (requirementsEnabled) {
                                                                if (axisStats.total === 0) {
                                                                    verdictLabel = 'No data';
                                                                } else if (axisStats.failed > 0) {
                                                                    verdictLabel = 'âŒ FAIL';
                                                                    verdictClass = 'text-red-600 font-semibold';
                                                                } else {
                                                                    verdictLabel = 'âœ… PASS';
                                                                    verdictClass = 'text-green-600 font-semibold';
                                                                }
                                                            }

                                                            return (
                                                                <div key={axisKey} className="border rounded-lg p-4">
                                                                    <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-3 border-b pb-3 mb-3">
                                                                        <div>
                                                                            <div className="flex items-center gap-3 flex-wrap">
                                                                                <h4 className="text-xl font-semibold">
                                                                                    {isUngrouped ? 'Ungrouped Markers' : `Axis ${axisKey}`}
                                                                                </h4>
                                                                                {requirementsEnabled && (
                                                                                    <span className={verdictClass}>{verdictLabel}</span>
                                                                                )}
                                                                                {axisErrorCount > 0 && (
                                                                                    <span className="text-sm font-medium text-red-600">{axisErrorCount} error{axisErrorCount !== 1 ? 's' : ''}</span>
                                                                                )}
                                                                            </div>
                                                                            <div className="text-sm text-gray-600 flex flex-wrap gap-4 mt-2">
                                                                                {!isUngrouped && (
                                                                                    <>
                                                                                        <span>Distance: {axisDistance != null ? `${axisDistance}mm` : 'N/A'}</span>
                                                                                        {reportRequirements?.maxLatency != null && (
                                                                                            <span>Max Latency â‰¤ {reportRequirements.maxLatency}ms</span>
                                                                                        )}
                                                                                        {requirementRange && (
                                                                                            <>
                                                                                                {requirementRange.minRespond != null && (
                                                                                                    <span>Min Respond â‰¥ {requirementRange.minRespond}mm</span>
                                                                                                )}
                                                                                                {requirementRange.mustNotRespond != null && (
                                                                                                    <span>Must NOT Respond &gt; {requirementRange.mustNotRespond}mm</span>
                                                                                                )}
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {isUngrouped && (
                                                                                    <span>Markers without axis/direction assignments.</span>
                                                                                )}
                                                                            </div>
                                                                        </div>
                                                                        <div className="text-sm text-gray-600">
                                                                            <div>Measurements: {axisStats.total}</div>
                                                                            {requirementsEnabled && (
                                                                                <div>Pass: {axisStats.passed} Â· Fail: {axisStats.failed}</div>
                                                                            )}
                                                                        </div>
                                                                    </div>

                                                                    <div className="overflow-x-auto">
                                                                        {axisTimestamps.length === 0 ? (
                                                                            <p className="text-sm text-gray-500">No measurements recorded for this section.</p>
                                                                        ) : (
                                                                            <table className="w-full text-xs md:text-sm">
                                                                                <thead className="bg-gray-50">
                                                                                    <tr>
                                                                                        <th className="px-3 py-2 text-left">Time (s)</th>
                                                                                        <th className="px-3 py-2 text-left">Timecode</th>
                                                                                        <th className="px-3 py-2 text-left">Label</th>
                                                                                        {isUngrouped && (
                                                                                            <>
                                                                                                <th className="px-3 py-2 text-left">Axis</th>
                                                                                                <th className="px-3 py-2 text-left">Direction</th>
                                                                                            </>
                                                                                        )}
                                                                                        <th className="px-3 py-2 text-left">Note</th>
                                                                                        <th className="px-3 py-2 text-right">Latency</th>
                                                                                        <th className="px-3 py-2 text-left">Included?</th>
                                                                                    </tr>
                                                                                </thead>
                                                                                <tbody>
                                                                                    {axisTimestamps.map(ts => (
                                                                                        <tr key={ts.id} className="border-t">
                                                                                            <td className="px-3 py-2 font-mono">{ts.time || '-'}</td>
                                                                                            <td className="px-3 py-2 font-mono text-xs">{ts.recordIn || '-'}</td>
                                                                                            <td className="px-3 py-2">{ts.label}</td>
                                                                                            {isUngrouped && (
                                                                                                <>
                                                                                                    <td className="px-3 py-2">{ts.axis || '-'}</td>
                                                                                                    <td className="px-3 py-2">{ts.direction || '-'}</td>
                                                                                                </>
                                                                                            )}
                                                                                            <td className="px-3 py-2 text-xs">{ts.note || '-'}</td>
                                                                                            <td className="px-3 py-2 text-right font-mono">{ts.latency || '-'}</td>
                                                                                            <td className="px-3 py-2">{ts.excludeFromStats ? 'No' : 'Yes'}</td>
                                                                                        </tr>
                                                                                    ))}
                                                                                </tbody>
                                                                            </table>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            )}

                                            {tc.executions.some(ex => (ex.hardware || []).length > 0) && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Hardware Coverage</h3>
                                                    <div className="space-y-3">
                                                        {tc.executions.map(ex => (
                                                            <div key={ex.id} className="border rounded-lg p-3">
                                                                <div className="font-medium text-sm">{ex.name}</div>
                                                                {(ex.hardware || []).length > 0 ? (
                                                                    <div className="flex flex-wrap gap-2 mt-2">
                                                                        {ex.hardware.map(hw => (
                                                                            <span key={hw.id} className="px-2 py-0.5 bg-gray-100 rounded-full text-xs text-gray-700">
                                                                                {[hw.type, hw.name].filter(Boolean).join(' â€¢ ') || 'Device'}
                                                                                {hw.serialNumber ? ` (${hw.serialNumber})` : ''}
                                                                            </span>
                                                                        ))}
                                                                    </div>
                                                                ) : (
                                                                    <p className="text-xs text-gray-500 mt-2">No hardware documented.</p>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </div>
                );
            };

            const renderDefectView = () => {
                const normalizedFilter = defectFilter.trim().toLowerCase();
                const filteredDefects = defects.filter(defect => {
                    if (!normalizedFilter) return true;
                    const haystack = [
                        defect.title,
                        defect.description,
                        defect.status,
                        defect.owner,
                        defect.severity
                    ].join(' ').toLowerCase();
                    return haystack.includes(normalizedFilter);
                });

                return (
                    <div className="p-6 space-y-6">
                        <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 flex items-start space-x-3">
                            <div className="text-3xl">âš ï¸</div>
                            <div>
                                <h2 className="text-lg font-semibold text-amber-900">Release Candidate Only</h2>
                                <p className="text-sm text-amber-800">
                                    This build is provided as Hardware Latency Tester v3.9 Release Candidate.
                                    Please avoid using it in production until all open defects are resolved.
                                </p>
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow p-4">
                            <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between mb-4">
                                <div>
                                    <h2 className="text-2xl font-bold">v3.9 RC Defect Register</h2>
                                    <p className="text-sm text-gray-500">
                                        Track and update issues discovered while evaluating this release candidate.
                                    </p>
                                </div>
                                <div className="flex flex-wrap gap-2">
                                    <input
                                        type="text"
                                        value={defectFilter}
                                        onChange={(e) => setDefectFilter(e.target.value)}
                                        placeholder="Filter defects"
                                        className="px-3 py-2 border rounded"
                                    />
                                    <button
                                        onClick={addDefect}
                                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        <Icon name="plus" /> New Defect
                                    </button>
                                    <button
                                        onClick={exportDefectsDocument}
                                        className="px-4 py-2 bg-gray-100 border rounded hover:bg-gray-200"
                                        disabled={defects.length === 0}
                                    >
                                        <Icon name="download" /> Save Document
                                    </button>
                                </div>
                            </div>

                            {filteredDefects.length === 0 ? (
                                <p className="text-sm text-gray-500">
                                    No defects match the current filter. Add a new record or adjust the filter criteria.
                                </p>
                            ) : (
                                <div className="overflow-x-auto">
                                    <table className="min-w-full text-sm">
                                        <thead className="bg-gray-50">
                                            <tr>
                                                <th className="px-3 py-2 text-left">Title</th>
                                                <th className="px-3 py-2 text-left">Description</th>
                                                <th className="px-3 py-2 text-left">Status</th>
                                                <th className="px-3 py-2 text-left">Severity</th>
                                                <th className="px-3 py-2 text-left">Owner</th>
                                                <th className="px-3 py-2 text-left">Updated</th>
                                                <th className="px-3 py-2 text-center">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {filteredDefects.map(defect => (
                                                <tr key={defect.id} className="border-t align-top">
                                                    <td className="px-3 py-2 w-48">
                                                        <input
                                                            type="text"
                                                            value={defect.title}
                                                            onChange={(e) => updateDefectField(defect.id, 'title', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                            placeholder="e.g. CSV import fails"
                                                        />
                                                    </td>
                                                    <td className="px-3 py-2">
                                                        <textarea
                                                            value={defect.description}
                                                            onChange={(e) => updateDefectField(defect.id, 'description', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                            style={{ minHeight: '60px' }}
                                                            placeholder="Describe the failure, reproduction steps, and impact"
                                                        />
                                                    </td>
                                                    <td className="px-3 py-2 w-40">
                                                        <select
                                                            value={defect.status}
                                                            onChange={(e) => updateDefectField(defect.id, 'status', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                        >
                                                            {DEFECT_STATUSES.map(status => (
                                                                <option key={status} value={status}>{status}</option>
                                                            ))}
                                                        </select>
                                                    </td>
                                                    <td className="px-3 py-2 w-32">
                                                        <select
                                                            value={defect.severity}
                                                            onChange={(e) => updateDefectField(defect.id, 'severity', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                        >
                                                            {DEFECT_SEVERITIES.map(severity => (
                                                                <option key={severity} value={severity}>{severity}</option>
                                                            ))}
                                                        </select>
                                                    </td>
                                                    <td className="px-3 py-2 w-32">
                                                        <input
                                                            type="text"
                                                            value={defect.owner}
                                                            onChange={(e) => updateDefectField(defect.id, 'owner', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                            placeholder="Assignee"
                                                        />
                                                    </td>
                                                    <td className="px-3 py-2 text-sm text-gray-500 w-40">
                                                        {new Date(defect.lastUpdated).toLocaleString()}
                                                    </td>
                                                    <td className="px-3 py-2 text-center w-20">
                                                        <button
                                                            onClick={() => deleteDefect(defect.id)}
                                                            className="text-red-600 hover:text-red-800"
                                                        >
                                                            <Icon name="trash-2" />
                                                        </button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>

                        <div className="bg-white rounded-lg shadow p-4 text-sm text-gray-600">
                            <p>
                                The canonical defect register for this release candidate lives at
                                <code className="mx-1 bg-gray-100 px-1 py-0.5 rounded">release-candidates/v3.9-rc-defects.json</code>.
                                You can edit that file directly in a text editor or synchronize it by importing and exporting
                                from the GUI controls above.
                            </p>
                            <p className="mt-2">
                                To refresh this table from a manually edited document use the global <strong>Import</strong>
                                button and select the JSON file. Saving from this view will download a ready-to-commit
                                replacement document.
                            </p>
                        </div>
                    </div>
                );
            };

            const renderImportModal = () => {
                if (!importDialog) return null;
                const { parsed, form, targetTestCaseId } = importDialog;
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white rounded-lg shadow-xl w-full max-w-5xl max-h-[90vh] overflow-y-auto">
                            <div className="px-6 py-4 border-b flex items-center justify-between">
                                <div>
                                    <h2 className="text-xl font-semibold">CSV Import Wizard</h2>
                                    <p className="text-sm text-gray-500">Provide test case context before creating the execution.</p>
                                </div>
                                <button onClick={closeImportDialog} className="text-gray-500 hover:text-gray-700">
                                    <Icon name="x" />
                                </button>
                            </div>
                            <div className="p-6 space-y-6">
                                <div className="grid md:grid-cols-2 gap-4">
                                    <div className="bg-gray-50 rounded-lg p-4">
                                        <h3 className="font-semibold mb-2">File Insights</h3>
                                        <p className="text-sm"><span className="font-medium">File:</span> {importDialog.fileName}</p>
                                        <p className="text-sm"><span className="font-medium">Detected FPS:</span> {parsed.fps}</p>
                                        <p className="text-sm"><span className="font-medium">Timestamps:</span> {parsed.timestamps.length}</p>
                                        <p className="text-sm"><span className="font-medium">Axes:</span> {parsed.axesFound.length > 0 ? parsed.axesFound.join(', ') : 'N/A'}</p>
                                        {parsed.metadata?.abNumber && (
                                            <p className="text-sm text-gray-600 mt-2">Suggested DUT: {parsed.metadata.abNumber}</p>
                                        )}
                                    </div>
                                    <div className="bg-gray-50 rounded-lg p-4 space-y-3">
                                        <div>
                                            <label className="text-sm font-medium">Attach to Test Case</label>
                                            <select
                                                className="w-full border rounded px-3 py-2"
                                                value={targetTestCaseId}
                                                onChange={(e) => updateImportTarget(e.target.value)}
                                            >
                                                <option value="new">â• Create new test case</option>
                                                {testCases.map(tc => (
                                                    <option key={tc.id} value={tc.id}>{tc.name}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Test Case Name</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.testCaseName}
                                                onChange={(e) => updateImportFormField('testCaseName', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Execution Name</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.executionName}
                                                onChange={(e) => updateImportFormField('executionName', e.target.value)}
                                            />
                                        </div>
                                    </div>
                                </div>

                                <div className="grid md:grid-cols-2 gap-4">
                                    <div className="space-y-3">
                                        <h3 className="font-semibold">Test Environment</h3>
                                        <div>
                                            <label className="text-sm font-medium">Environment Name</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.name}
                                                onChange={(e) => updateImportEnvironmentField('name', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Location</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.location}
                                                onChange={(e) => updateImportEnvironmentField('location', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Owner / Operator</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.owner}
                                                onChange={(e) => updateImportEnvironmentField('owner', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Primary DUT / Build</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.dut}
                                                onChange={(e) => updateImportEnvironmentField('dut', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Notes</label>
                                            <textarea
                                                className="w-full border rounded px-3 py-2"
                                                rows="3"
                                                value={form.environment.notes}
                                                onChange={(e) => updateImportEnvironmentField('notes', e.target.value)}
                                            ></textarea>
                                        </div>
                                    </div>
                                    <div className="space-y-3">
                                        <h3 className="font-semibold">Execution Notes</h3>
                                        <textarea
                                            className="w-full border rounded px-3 py-2"
                                            rows="6"
                                            value={form.executionNotes}
                                            onChange={(e) => updateImportFormField('executionNotes', e.target.value)}
                                            placeholder="Describe the scenario, stimulus, or anything unique about this run."
                                        ></textarea>
                                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                                            Suggestions are generated from the CSV metadata and filename. Adjust anything that
                                            differs for this import.
                                        </div>
                                    </div>
                                </div>

                                <div>
                                    <div className="flex items-center justify-between mb-3">
                                        <h3 className="font-semibold">Test Hardware</h3>
                                        <button
                                            onClick={addHardwareToImport}
                                            className="px-3 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                                        >
                                            <Icon name="plus" /> Add Hardware
                                        </button>
                                    </div>
                                    {form.hardware.length === 0 ? (
                                        <p className="text-sm text-gray-500">No hardware linked yet.</p>
                                    ) : (
                                        <div className="space-y-3">
                                            {form.hardware.map(hw => (
                                                <div key={hw.id} className="border rounded-lg p-3 space-y-3">
                                                    <div className="grid md:grid-cols-3 gap-3">
                                                        <div>
                                                            <label className="text-sm font-medium">Hardware Type</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.type}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'type', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Name</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.name}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'name', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Serial Number</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.serialNumber}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'serialNumber', e.target.value)}
                                                            />
                                                        </div>
                                                    </div>
                                                    <div className="grid md:grid-cols-3 gap-3">
                                                        <div>
                                                            <label className="text-sm font-medium">Version</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.version}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'version', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Revision</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.revision}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'revision', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Notes</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.notes}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'notes', e.target.value)}
                                                            />
                                                        </div>
                                                    </div>
                                                    <div className="text-right">
                                                        <button
                                                            onClick={() => removeHardwareFromImport(hw.id)}
                                                            className="text-sm text-red-600 hover:text-red-800"
                                                        >
                                                            <Icon name="trash-2" /> Remove
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="px-6 py-4 border-t flex justify-end gap-3 bg-gray-50">
                                <button onClick={closeImportDialog} className="px-4 py-2 border rounded">Cancel</button>
                                <button
                                    onClick={finalizeImportDialog}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Create Execution
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // Execution View
            const renderExecutionView = () => {
                if (!currentTestCase || !currentExecution) {
                    return (
                        <div className="flex items-center justify-center h-full">
                            <div className="text-center">
                                <p className="text-gray-500 text-lg mb-4">No test case loaded</p>
                                <button
                                    onClick={() => {
                                        const newTC = createNewTestCase();
                                        setTestCases([...testCases, newTC]);
                                        setActiveTestCase(newTC.id);
                                        setActiveExecution(newTC.executions[0].id);
                                    }}
                                    className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                >
                                    <Icon name="plus" /> Create New Test Case
                                </button>
                            </div>
                        </div>
                    );
                }

                const timestamps = currentExecution.timestamps;
                const requirements = mergeExecutionRequirements(currentExecution.requirements);
                const overallStats = getStatistics(timestamps, requirements);
                const axisGroups = groupByAxis(timestamps);
                const ungroupedCount = timestamps.filter(ts => !ts.isError && (!ts.axis || !ts.direction)).length;
                const errorEvents = timestamps.filter(ts => ts.isError);
                const axisSummaries = AXES.map(axis => ({
                    axis,
                    stats: getStatistics(timestamps.filter(ts => ts.axis === axis), requirements)
                }));

                // Group errors by error number
                const errorsByNumber = {};
                errorEvents.forEach(err => {
                    if (err.errorNumber) {
                        if (!errorsByNumber[err.errorNumber]) {
                            errorsByNumber[err.errorNumber] = [];
                        }
                        errorsByNumber[err.errorNumber].push(err);
                    }
                });

                return (
                    <div className="p-6">
                        {/* Test Case Header */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex items-center justify-between">
                                <div className="flex-1">
                                    <input
                                        type="text"
                                        value={currentTestCase.name}
                                        onChange={(e) => updateTestCaseName(currentTestCase.id, e.target.value)}
                                        className="text-xl font-bold border-b border-transparent hover:border-gray-300 focus:border-blue-500 outline-none px-2 py-1"
                                    />
                                </div>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={() => {
                                            setSelectedForReport(prev =>
                                                prev.includes(currentTestCase.id)
                                                    ? prev.filter(id => id !== currentTestCase.id)
                                                    : [...prev, currentTestCase.id]
                                            );
                                        }}
                                        className={`px-3 py-1 rounded ${
                                            selectedForReport.includes(currentTestCase.id)
                                                ? 'bg-green-600 text-white'
                                                : 'bg-gray-200 text-gray-700'
                                        }`}
                                    >
                                        <Icon name={selectedForReport.includes(currentTestCase.id) ? 'check' : 'eye'} />
                                        {selectedForReport.includes(currentTestCase.id) ? 'In Report' : 'Add to Report'}
                                    </button>
                                    <button
                                        onClick={() => deleteTestCase(currentTestCase.id)}
                                        className="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700"
                                    >
                                        <Icon name="trash-2" /> Delete Test Case
                                    </button>
                                </div>
                            </div>
                        </div>

                        {ungroupedCount > 0 && (
                            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                                <div className="text-sm font-semibold text-yellow-800">
                                    Import summary alert
                                </div>
                                <p className="text-xs md:text-sm text-yellow-700 mt-1">
                                    This import contains <span className="font-semibold">{ungroupedCount}</span> marker{ungroupedCount !== 1 ? 's' : ''} without axis/direction tags. Use the Ungrouped bucket below to assign an axis and direction so they appear in the correct sections.
                                </p>
                            </div>
                        )}

                        {/* Test Environment */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <h3 className="font-semibold mb-3">Test Environment</h3>
                            <div className="grid md:grid-cols-2 gap-3">
                                <div>
                                    <label className="block text-sm font-medium mb-1">Environment Name</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.name || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('name', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Location</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.location || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('location', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Owner / Operator</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.owner || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('owner', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Primary DUT / Build</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.dut || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('dut', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                            </div>
                            <div className="mt-3">
                                <label className="block text-sm font-medium mb-1">Notes</label>
                                <textarea
                                    value={currentTestCase.environment?.notes || ''}
                                    onChange={(e) => updateTestCaseEnvironmentField('notes', e.target.value)}
                                    className="w-full border rounded px-3 py-2"
                                    rows="3"
                                ></textarea>
                            </div>
                        </div>

                        {/* Requirements Selection */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                                <div>
                                    <h3 className="font-semibold mb-1">Pass/Fail Requirements</h3>
                                    <p className="text-xs text-gray-500">Set min/max read ranges and responsiveness latency for this execution.</p>
                                </div>
                                <div className="flex flex-wrap gap-2 items-center">
                                    <select
                                        className="px-3 py-1.5 border rounded text-sm"
                                        value={currentTestCase.requirementTemplateId || ''}
                                        onChange={(e) => {
                                            const nextTemplateId = e.target.value || null;
                                            updateTestCaseTemplateSelection(nextTemplateId);
                                            if (nextTemplateId) {
                                                applyTemplateToExecution(currentExecution.id, nextTemplateId);
                                            }
                                        }}
                                    >
                                        <option value="">No Template Selected</option>
                                        {requirementTemplates.map(template => (
                                            <option key={template.id} value={template.id}>{template.name}</option>
                                        ))}
                                    </select>
                                    <button
                                        onClick={() => applyTemplateToExecution(currentExecution.id, currentTestCase.requirementTemplateId)}
                                        className="px-3 py-1.5 text-sm border rounded text-gray-700 hover:bg-gray-50"
                                        disabled={!currentTestCase.requirementTemplateId}
                                    >
                                        Apply to Execution
                                    </button>
                                    <button
                                        onClick={() => applyTemplateToAllExecutions(currentTestCase.requirementTemplateId)}
                                        className="px-3 py-1.5 text-sm border rounded text-gray-700 hover:bg-gray-50"
                                        disabled={!currentTestCase.requirementTemplateId}
                                    >
                                        Apply to All
                                    </button>
                                    <button
                                        onClick={() => setView('requirements')}
                                        className="px-3 py-1.5 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        Manage Templates
                                    </button>
                                </div>
                            </div>

                            <div className="flex items-center mt-4 gap-2">
                                <input
                                    type="checkbox"
                                    checked={requirements.enabled}
                                    onChange={(e) => updateExecutionRequirements('enabled', e.target.checked)}
                                    className="w-4 h-4"
                                />
                                <span className="text-sm font-medium">Enable requirements checking for this execution</span>
                            </div>

                            {requirements.enabled && (
                                <>
                                    <div className="mt-4">
                                        <label className="block text-sm mb-1">Max Latency (ms)</label>
                                        <input
                                            type="number"
                                            value={requirements.maxLatency}
                                            onChange={(e) => updateExecutionRequirements('maxLatency', parseFloat(e.target.value) || 100)}
                                            className="w-32 px-2 py-1 border rounded text-sm"
                                        />
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                                        {AXES.map(axis => (
                                            <div key={axis} className="border rounded p-3">
                                                <div className="font-medium mb-2">{axis} Axis</div>
                                                <div className="space-y-2">
                                                    <div>
                                                        <label className="block text-xs mb-1">Min Must Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.minRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('minRespondRanges', {
                                                                ...requirements.minRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs mb-1">Must NOT Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.mustNotRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('mustNotRespondRanges', {
                                                                ...requirements.mustNotRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                        </div>

                        {/* Execution Details */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex items-center justify-between mb-3 flex-wrap gap-2">
                                <h3 className="font-semibold">Execution Details</h3>
                                <button
                                    onClick={() => deleteExecution(currentExecution.id)}
                                    className="px-3 py-1.5 text-sm text-red-600 border border-red-200 rounded hover:bg-red-50"
                                >
                                    <Icon name="trash-2" /> Delete Execution
                                </button>
                            </div>
                            <div className="grid md:grid-cols-2 gap-3">
                                <div>
                                    <label className="block text-sm font-medium mb-1">Execution Name</label>
                                    <input
                                        type="text"
                                        value={currentExecution.name}
                                        onChange={(e) => updateExecutionField(currentExecution.id, 'name', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">FPS (from import)</label>
                                    <input
                                        type="text"
                                        value={currentExecution.fps || ''}
                                        onChange={(e) => updateExecutionField(currentExecution.id, 'fps', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                        placeholder="e.g., 240"
                                    />
                                </div>
                            </div>
                            <div className="mt-3">
                                <label className="block text-sm font-medium mb-1">Notes</label>
                                <textarea
                                    value={currentExecution.notes || ''}
                                    onChange={(e) => updateExecutionField(currentExecution.id, 'notes', e.target.value)}
                                    className="w-full border rounded px-3 py-2"
                                    rows="3"
                                    placeholder="Add any observations for this execution."
                                ></textarea>
                            </div>
                        </div>

                        {/* Execution Hardware */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex items-center justify-between mb-3">
                                <h3 className="font-semibold">Execution Hardware</h3>
                                <button
                                    onClick={addHardwareToExecution}
                                    className="px-3 py-1.5 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
                                >
                                    <Icon name="plus" /> Add Hardware
                                </button>
                            </div>
                            {(!currentExecution.hardware || currentExecution.hardware.length === 0) ? (
                                <p className="text-sm text-gray-500">No hardware linked. Use the button above to add devices.</p>
                            ) : (
                                <div className="space-y-3">
                                    {currentExecution.hardware.map(hw => (
                                        <div key={hw.id} className="border rounded-lg p-3 space-y-3">
                                            <div className="grid md:grid-cols-3 gap-3">
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Type</label>
                                                    <input
                                                        type="text"
                                                        value={hw.type}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'type', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Name</label>
                                                    <input
                                                        type="text"
                                                        value={hw.name}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'name', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Serial</label>
                                                    <input
                                                        type="text"
                                                        value={hw.serialNumber}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'serialNumber', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                            </div>
                                            <div className="grid md:grid-cols-3 gap-3">
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Version</label>
                                                    <input
                                                        type="text"
                                                        value={hw.version}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'version', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Revision</label>
                                                    <input
                                                        type="text"
                                                        value={hw.revision}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'revision', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Notes</label>
                                                    <input
                                                        type="text"
                                                        value={hw.notes}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'notes', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                            </div>
                                            <div className="text-right">
                                                <button
                                                    onClick={() => removeExecutionHardware(hw.id)}
                                                    className="text-sm text-red-600 hover:text-red-800"
                                                >
                                                    <Icon name="trash-2" /> Remove
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        {/* Requirements Settings */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <h3 className="font-semibold mb-3">Pass/Fail Requirements</h3>
                            <div className="flex items-center mb-3">
                                <input
                                    type="checkbox"
                                    checked={requirements.enabled}
                                    onChange={(e) => updateExecutionRequirements('enabled', e.target.checked)}
                                    className="w-4 h-4 mr-2"
                                />
                                <label className="text-sm font-medium">Enable Requirements Checking</label>
                            </div>

                            {requirements.enabled && (
                                <>
                                    <div className="mb-3">
                                        <label className="block text-sm mb-1">Max Latency (ms)</label>
                                        <input
                                            type="number"
                                            value={requirements.maxLatency}
                                            onChange={(e) => updateExecutionRequirements('maxLatency', parseFloat(e.target.value) || 100)}
                                            className="w-32 px-2 py-1 border rounded text-sm"
                                        />
                                    </div>

                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {AXES.map(axis => (
                                            <div key={axis} className="border rounded p-3">
                                                <div className="font-medium mb-2">{axis} Axis</div>
                                                <div className="space-y-2">
                                                    <div>
                                                        <label className="block text-xs mb-1">Min Must Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.minRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('minRespondRanges', {
                                                                ...requirements.minRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs mb-1">Must NOT Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.mustNotRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('mustNotRespondRanges', {
                                                                ...requirements.mustNotRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                        </div>

                        {/* Overall Statistics */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <h3 className="font-semibold mb-2">Overall Statistics</h3>
                            <div className="grid grid-cols-4 gap-4 text-center">
                                <div>
                                    <div className="text-lg font-bold text-green-600">{formatMsToTime(overallStats.min)}</div>
                                    <div className="text-sm text-gray-600">Min</div>
                                </div>
                                <div>
                                    <div className="text-lg font-bold text-blue-600">{formatMsToTime(overallStats.avg)}</div>
                                    <div className="text-sm text-gray-600">Avg</div>
                                </div>
                                <div>
                                    <div className="text-lg font-bold text-red-600">{formatMsToTime(overallStats.max)}</div>
                                    <div className="text-sm text-gray-600">Max</div>
                                </div>
                                <div>
                                    <div className="text-lg font-bold text-gray-600">{overallStats.total}</div>
                                    <div className="text-sm text-gray-600">Count</div>
                                </div>
                            </div>
                            {requirements.enabled && (
                                <div className="mt-3 text-center border-t pt-3">
                                    <div className="text-sm">
                                        Pass: <span className="text-green-600 font-bold">{overallStats.passed}</span> /
                                        Fail: <span className="text-red-600 font-bold">{overallStats.failed}</span>
                                        <span className="ml-2">({overallStats.passRate.toFixed(1)}%)</span>
                                    </div>
                                </div>
                            )}
                            <div className="mt-4">
                                <h4 className="text-sm font-semibold text-gray-700 uppercase tracking-wide">Axis Breakdown</h4>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mt-2 text-sm">
                                    {axisSummaries.map(({ axis, stats }) => (
                                        <div key={axis} className="border rounded-lg p-3 bg-gray-50">
                                            <div className="flex items-center justify-between text-xs text-gray-500">
                                                <span className="font-semibold text-gray-700">{axis}-Axis</span>
                                                <span>{stats.total} pts</span>
                                            </div>
                                            <div className="mt-2 flex justify-between text-xs">
                                                <span className="text-gray-600">Min</span>
                                                <span className="font-mono font-semibold text-green-600">{stats.total === 0 ? '-' : formatMsToTime(stats.min)}</span>
                                            </div>
                                            <div className="flex justify-between text-xs mt-1">
                                                <span className="text-gray-600">Avg</span>
                                                <span className="font-mono font-semibold text-blue-600">{stats.total === 0 ? '-' : formatMsToTime(stats.avg)}</span>
                                            </div>
                                            <div className="flex justify-between text-xs mt-1">
                                                <span className="text-gray-600">Max</span>
                                                <span className="font-mono font-semibold text-red-600">{stats.total === 0 ? '-' : formatMsToTime(stats.max)}</span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>

                        {/* Error Events Grouped */}
                        {Object.keys(errorsByNumber).length > 0 && (
                            <div className="bg-yellow-50 rounded-lg shadow p-4 mb-4">
                                <h3 className="font-semibold mb-2">Error Events (Grouped)</h3>
                                <div className="space-y-2">
                                    {Object.entries(errorsByNumber).map(([errorNum, errors]) => (
                                        <div key={errorNum} className="bg-white rounded p-2 border border-yellow-200">
                                            <div className="font-medium text-sm">Error #{errorNum}</div>
                                            {errors.map(err => (
                                                <div key={err.id} className="text-xs text-gray-600 ml-2">
                                                    {err.note}
                                                </div>
                                            ))}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Per-Axis Tables */}
                        <div className="space-y-4">
                                {Object.entries(axisGroups).map(([axisKey, axisTimestamps]) => {
                                    const isUngrouped = axisKey === UNGROUPED_BUCKET;
                                    const axis = isUngrouped ? null : axisKey[0];
                                    const direction = isUngrouped ? null : axisKey[1];
                                    const axisStats = isUngrouped
                                        ? getStatistics(axisTimestamps, requirements)
                                        : getAxisStatistics(axisTimestamps, axis, direction, requirements);
                                    const distance = !isUngrouped ? getDistanceForAxisKey(currentTestCase, axisKey) : null;
                                    const axisHasComparableSamples = axisTimestamps.some(ts =>
                                        !ts.isError && ts.latencyMs != null && !ts.excludeFromStats
                                    );

                                    return (
                                        <div key={axisKey} className="bg-white rounded-lg shadow overflow-hidden">
                                            <div className="p-4 bg-gray-50 border-b">
                                                <div className="flex items-center justify-between flex-wrap gap-2">
                                                    <div className="flex items-center flex-wrap gap-2">
                                                        <h3 className="font-semibold flex items-center gap-2">
                                                            {axisKey}
                                                            {!isUngrouped && distance && (
                                                                <span className="text-sm text-gray-600">({distance}mm)</span>
                                                            )}
                                                        </h3>
                                                        {isUngrouped && (
                                                            <span className="inline-flex items-center px-2 py-0.5 text-xs font-semibold rounded-full bg-yellow-100 text-yellow-800">
                                                                âš ï¸ Needs axis tags
                                                            </span>
                                                        )}
                                                    </div>
                                                    <div className="flex flex-wrap items-center gap-2 text-sm text-gray-600">
                                                        <span>
                                                            Min: {formatMsToTime(axisStats.min)} |
                                                            Avg: {formatMsToTime(axisStats.avg)} |
                                                            Max: {formatMsToTime(axisStats.max)}
                                                            {requirements.enabled && (
                                                                <span className="ml-2">
                                                                    | Pass: {axisStats.passRate.toFixed(1)}% ({axisStats.passed}/{axisStats.total})
                                                                </span>
                                                            )}
                                                        </span>
                                                        {!isUngrouped && (
                                                            <button
                                                                onClick={() => addToComparison(activeTestCase, activeExecution, axisKey)}
                                                                disabled={!axisHasComparableSamples}
                                                                className={`inline-flex items-center gap-1 ${axisHasComparableSamples ? 'text-blue-600 hover:text-blue-800' : 'text-gray-400 cursor-not-allowed'}`}
                                                                title={axisHasComparableSamples ? 'Add this axis to the comparison view' : 'No valid samples to compare'}
                                                            >
                                                                <Icon name="git-compare" /> Compare axis
                                                            </button>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="overflow-x-auto">
                                                <table className="w-full text-sm">
                                                    <thead className="bg-gray-50">
                                                        <tr>
                                                            <th className="px-4 py-2 text-left">Include</th>
                                                            <th className="px-4 py-2 text-left">Time (s)</th>
                                                            <th className="px-4 py-2 text-left">Timecode</th>
                                                            <th className="px-4 py-2 text-left">Label</th>
                                                            {isUngrouped && (
                                                                <>
                                                                    <th className="px-4 py-2 text-left">Axis</th>
                                                                    <th className="px-4 py-2 text-left">Direction</th>
                                                                </>
                                                            )}
                                                            <th className="px-4 py-2 text-left">Note</th>
                                                            <th className="px-4 py-2 text-right">Latency</th>
                                                            <th className="px-4 py-2 text-center">Actions</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {axisTimestamps.map(ts => {
                                                            const rowClass = ts.isError ? 'row-error' :
                                                                ts.excludeFromStats ? 'row-excluded' :
                                                                showPassFailHighlight && requirements.enabled && ts.latencyMs ?
                                                                    (ts.latencyMs <= requirements.maxLatency ? 'row-pass' : 'row-fail') : '';

                                                            return (
                                                                <tr key={ts.id} className={`${rowClass} border-t hover:bg-gray-50${ts.isMarked ? ' bg-amber-50' : ''}`}>
                                                                    <td className="px-4 py-2">
                                                                        {!ts.isError && (
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={!ts.excludeFromStats}
                                                                                onChange={() => toggleMarkerInclusion(ts.id)}
                                                                                className="w-4 h-4"
                                                                            />
                                                                        )}
                                                                    </td>
                                                                    <td className="px-4 py-2 font-mono">{ts.time}</td>
                                                                    <td className="px-4 py-2 font-mono text-xs">{ts.recordIn}</td>
                                                                    <td className="px-4 py-2">
                                                                        <span className={`px-2 py-1 rounded text-xs font-medium ${
                                                                            ts.label === 'TagOn' ? 'bg-green-100 text-green-800' :
                                                                            ts.label === 'TagOff' ? 'bg-blue-100 text-blue-800' :
                                                                            'bg-red-100 text-red-800'
                                                                        }`}>
                                                                            {ts.label}
                                                                        </span>
                                                                    </td>
                                                                    {isUngrouped && (
                                                                        <>
                                                                            <td className="px-4 py-2">
                                                                                <select
                                                                                    value={ts.axis || ''}
                                                                                    onChange={(e) => updateTimestampAxisDirection(ts.id, e.target.value || '', ts.direction || '')}
                                                                                    className="w-full border rounded px-2 py-1 text-xs"
                                                                                >
                                                                                    <option value="">Select axis</option>
                                                                                    {AXES.map(axisOption => (
                                                                                        <option key={axisOption} value={axisOption}>{axisOption}</option>
                                                                                    ))}
                                                                                </select>
                                                                            </td>
                                                                            <td className="px-4 py-2">
                                                                                <select
                                                                                    value={ts.direction || ''}
                                                                                    onChange={(e) => updateTimestampAxisDirection(ts.id, ts.axis || '', e.target.value || '')}
                                                                                    className="w-full border rounded px-2 py-1 text-xs"
                                                                                >
                                                                                    <option value="">Select direction</option>
                                                                                    <option value="+">+</option>
                                                                                    <option value="-">-</option>
                                                                                </select>
                                                                            </td>
                                                                        </>
                                                                    )}
                                                                    <td className="px-4 py-2 text-xs max-w-xs">
                                                                        <div className="flex items-center gap-2">
                                                                            <span
                                                                                className={`truncate ${ts.isMarked ? 'font-semibold text-amber-700' : ''}`}
                                                                                title={ts.note || (ts.isMarked ? 'Marked for follow-up' : '')}
                                                                            >
                                                                                {ts.note || (ts.isMarked ? 'Marked' : 'â€”')}
                                                                            </span>
                                                                            {!ts.isError && (
                                                                                <>
                                                                                    <button
                                                                                        onClick={() => handleEditTimestampNote(ts.id, ts.note || '')}
                                                                                        className="text-blue-600 hover:text-blue-800"
                                                                                        title="Add or edit note"
                                                                                    >
                                                                                        <Icon name="edit" />
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => toggleTimestampMark(ts.id)}
                                                                                        className={ts.isMarked ? 'text-amber-500 hover:text-amber-600' : 'text-gray-400 hover:text-gray-600'}
                                                                                        title={ts.isMarked ? 'Remove mark' : 'Mark this measurement'}
                                                                                    >
                                                                                        <Icon name={ts.isMarked ? 'star' : 'star-off'} />
                                                                                    </button>
                                                                                </>
                                                                            )}
                                                                        </div>
                                                                    </td>
                                                                    <td className="px-4 py-2 text-right font-mono font-bold">{ts.latency || '-'}</td>
                                                                    <td className="px-4 py-2 text-center">
                                                                        <button
                                                                            onClick={() => handleDeleteTimestamp(ts.id)}
                                                                            className="text-red-600 hover:text-red-800"
                                                                        >
                                                                            <Icon name="trash-2" />
                                                                        </button>
                                                                    </td>
                                                                </tr>
                                                            );
                                                        })}
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                );
            };

            const renderTraceabilityView = () => {
                const usages = [];
                testCases.forEach(tc => {
                    tc.executions.forEach(ex => {
                        (ex.hardware || []).forEach(hw => {
                            if (!hw) return;
                            const hasDetails = hw.type || hw.name || hw.serialNumber || hw.version || hw.revision;
                            if (!hasDetails) return;
                            usages.push({ hw, tc, ex });
                        });
                    });
                });

                if (usages.length === 0) {
                    return (
                        <div className="p-6">
                            <div className="bg-white rounded-lg shadow p-6 text-center">
                                <h3 className="text-lg font-semibold mb-2">No hardware tracked yet</h3>
                                <p className="text-sm text-gray-500">Add hardware to an execution to build a coverage map.</p>
                            </div>
                        </div>
                    );
                }

                const grouped = usages.reduce((acc, entry) => {
                    const serial = (entry.hw.serialNumber || '').trim().toLowerCase();
                    const fallback = `${(entry.hw.name || entry.hw.type || 'device').toLowerCase()}-${entry.hw.id}`;
                    const key = serial || fallback;
                    if (!acc[key]) {
                        acc[key] = {
                            key,
                            serial: entry.hw.serialNumber || '',
                            type: entry.hw.type || '',
                            name: entry.hw.name || '',
                            version: entry.hw.version || '',
                            revision: entry.hw.revision || '',
                            notes: entry.hw.notes || '',
                            usages: []
                        };
                    }
                    acc[key].usages.push({
                        testCaseId: entry.tc.id,
                        testCaseName: entry.tc.name,
                        executionId: entry.ex.id,
                        executionName: entry.ex.name
                    });
                    return acc;
                }, {});

                const filterValue = traceabilityFilter.toLowerCase();
                const devices = Object.values(grouped)
                    .filter(device => {
                        if (!filterValue) return true;
                        return [device.serial, device.name, device.type]
                            .some(val => (val || '').toLowerCase().includes(filterValue));
                    })
                    .sort((a, b) => b.usages.length - a.usages.length);

                return (
                    <div className="p-6 space-y-4">
                        <div className="flex flex-wrap items-center justify-between gap-3">
                            <div>
                                <h2 className="text-2xl font-bold">Device Traceability</h2>
                                <p className="text-sm text-gray-500">See which executions each device participated in.</p>
                            </div>
                            <input
                                type="text"
                                value={traceabilityFilter}
                                onChange={(e) => setTraceabilityFilter(e.target.value)}
                                className="border rounded px-3 py-2 w-64"
                                placeholder="Search by serial, name, type"
                            />
                        </div>
                        <div className="bg-white rounded-lg shadow overflow-hidden">
                            <table className="w-full text-sm">
                                <thead className="bg-gray-50">
                                    <tr>
                                        <th className="px-4 py-2 text-left">Type</th>
                                        <th className="px-4 py-2 text-left">Name</th>
                                        <th className="px-4 py-2 text-left">Serial</th>
                                        <th className="px-4 py-2 text-left">Version</th>
                                        <th className="px-4 py-2 text-left">Revision</th>
                                        <th className="px-4 py-2 text-left">Usage</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {devices.length === 0 ? (
                                        <tr>
                                            <td colSpan="6" className="px-4 py-4 text-center text-gray-500">No devices match your filter.</td>
                                        </tr>
                                    ) : (
                                        devices.map(device => (
                                            <tr key={device.key} className="border-t hover:bg-gray-50">
                                                <td className="px-4 py-3 font-medium">{device.type || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.name || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.serial || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.version || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.revision || 'â€”'}</td>
                                                <td className="px-4 py-3">
                                                    <div className="flex flex-wrap gap-2">
                                                        {device.usages.map((usage, index) => (
                                                            <span key={usage.executionId + index} className="px-2 py-0.5 bg-blue-100 text-blue-800 rounded-full text-xs">
                                                                {usage.testCaseName} Â· {usage.executionName}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </td>
                                            </tr>
                                        ))
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            };

            // Render comparison view
            const renderComparisonView = () => {
                if (comparisonExecutions.length === 0) {
                    return (
                        <div className="flex items-center justify-center h-full p-12">
                            <div className="text-center text-gray-500">
                                <Icon name="git-compare" />
                                <p className="mt-4">No executions added to comparison</p>
                                <p className="text-sm mt-2">Use "Add to Comparison" in execution view</p>
                            </div>
                        </div>
                    );
                }

                return (
                    <div className="p-6 space-y-4">
                        <div className="flex items-center justify-between">
                            <h2 className="text-2xl font-bold">Comparison View</h2>
                            <button
                                onClick={() => setComparisonExecutions([])}
                                className="text-sm text-red-600 hover:text-red-800"
                            >
                                Clear all
                            </button>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {comparisonExecutions.map(comp => {
                                const tc = testCases.find(testCase => testCase.id === comp.testCaseId);
                                const ex = tc?.executions.find(exec => exec.id === comp.executionId);

                                if (!tc || !ex) {
                                    return (
                                        <div key={comp.key} className="bg-white rounded-lg shadow p-4">
                                            <div className="flex items-center justify-between mb-2">
                                                <p className="text-sm text-red-600">Execution not available</p>
                                                <button
                                                    onClick={() => removeFromComparison(comp.key)}
                                                    className="text-red-600 hover:text-red-800"
                                                >
                                                    <Icon name="x" />
                                                </button>
                                            </div>
                                            <p className="text-xs text-gray-500">Remove this card and add it again.</p>
                                        </div>
                                    );
                                }

                                const executionRequirements = mergeExecutionRequirements(ex.requirements);
                                const filteredTimestamps = ex.timestamps.filter(ts => {
                                    if (ts.isError || ts.latencyMs == null || ts.excludeFromStats) return false;
                                    if (!comp.axisKey) return true;
                                    return ts.axis && ts.direction && (ts.axis + ts.direction) === comp.axisKey;
                                });
                                const stats = getStatistics(filteredTimestamps, executionRequirements);
                                const axisLabel = comp.axisKey ? `${comp.axisKey} axis` : 'All axes';
                                const heading = comp.axisKey ? `${ex.name} Â· ${comp.axisKey}` : ex.name;

                                return (
                                    <div key={comp.key} className="bg-white rounded-lg shadow p-4">
                                        <div className="flex items-center justify-between mb-3">
                                            <div>
                                                <h3 className="font-semibold">{tc.name}</h3>
                                                <p className="text-sm text-gray-600">{heading}</p>
                                                <p className="text-xs text-gray-500">{axisLabel}</p>
                                            </div>
                                            <button
                                                onClick={() => removeFromComparison(comp.key)}
                                                className="text-red-600 hover:text-red-800"
                                            >
                                                <Icon name="x" />
                                            </button>
                                        </div>
                                        {stats.total === 0 ? (
                                            <p className="text-sm text-gray-500">No valid measurements available for this selection.</p>
                                        ) : (
                                            <div className="space-y-2 text-sm">
                                                <div className="flex justify-between">
                                                    <span className="text-gray-600">Min:</span>
                                                    <span className="font-mono font-bold text-green-600">{formatMsToTime(stats.min)}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span className="text-gray-600">Avg:</span>
                                                    <span className="font-mono font-bold text-blue-600">{formatMsToTime(stats.avg)}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span className="text-gray-600">Max:</span>
                                                    <span className="font-mono font-bold text-red-600">{formatMsToTime(stats.max)}</span>
                                                </div>
                                                <div className="flex justify-between border-t pt-2">
                                                    <span className="text-gray-600">Count:</span>
                                                    <span className="font-bold">{stats.total}</span>
                                                </div>
                                                {executionRequirements.enabled && (
                                                    <div className="flex justify-between border-t pt-2">
                                                        <span className="text-gray-600">Pass Rate:</span>
                                                        <span className="font-bold">{stats.passRate.toFixed(1)}%</span>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            // Main render
            return (
                <div className="min-h-screen bg-gray-100">
                    {/* Header */}
                    <div className="bg-blue-600 text-white shadow-lg no-print">
                        <div className="px-6 py-4">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h1 className="text-2xl font-bold">Hardware Latency Tester</h1>
                                    <p className="text-blue-100 text-sm font-semibold">v3.9 Release Candidate (Evaluation Only)</p>
                                    <p className="text-xs text-amber-200 uppercase tracking-wide flex items-center gap-1">
                                        <Icon name="alert-triangle" /> Release Candidate - not approved for production
                                    </p>
                                </div>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={() => importRef.current?.click()}
                                        className="px-4 py-2 bg-blue-700 rounded hover:bg-blue-800"
                                    >
                                        <Icon name="upload" /> Import
                                    </button>
                                    <button
                                        onClick={handleExportJSON}
                                        className="px-4 py-2 bg-blue-700 rounded hover:bg-blue-800"
                                        disabled={testCases.length === 0}
                                    >
                                        <Icon name="download" /> Export
                                    </button>
                                    {currentTestCase && currentExecution && (
                                        <button
                                            onClick={() => addToComparison(activeTestCase, activeExecution)}
                                            disabled={!currentExecutionHasComparableSamples}
                                            title={currentExecutionHasComparableSamples ? 'Add the active execution to the comparison dashboard' : 'No valid latency measurements available for comparison'}
                                            className={`px-4 py-2 rounded ${currentExecutionHasComparableSamples ? 'bg-blue-700 hover:bg-blue-800' : 'bg-blue-300 cursor-not-allowed'}`}
                                        >
                                            <Icon name="git-compare" /> Add to Comparison
                                        </button>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Navigation */}
                        <div className="px-6 flex space-x-1 border-t border-blue-500">
                            <button
                                onClick={() => setView('execution')}
                                className={`px-4 py-2 ${view === 'execution' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="bar-chart" /> Execution
                            </button>
                            <button
                                onClick={() => setView('comparison')}
                                className={`px-4 py-2 ${view === 'comparison' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="git-compare" /> Comparison ({comparisonExecutions.length})
                            </button>
                            <button
                                onClick={() => setView('traceability')}
                                className={`px-4 py-2 ${view === 'traceability' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="hard-drive" /> Devices
                            </button>
                            <button
                                onClick={() => setView('report')}
                                className={`px-4 py-2 ${view === 'report' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="file-text" /> Report
                            </button>
                            <button
                                onClick={() => setView('defects')}
                                className={`px-4 py-2 ${view === 'defects' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="alert-triangle" /> Defects ({defects.length})
                            </button>
                        </div>
                    </div>

                    {/* Main Content */}
                    <div className="flex">
                        {/* Sidebar */}
                        {view === 'execution' && (
                            <div className="w-64 bg-white shadow-lg no-print" style={{ minHeight: 'calc(100vh - 140px)' }}>
                                <div className="p-4">
                                    <div className="mb-4">
                                        <h3 className="font-semibold mb-2">Test Cases</h3>
                                        <button
                                            onClick={() => {
                                                const newTC = createNewTestCase();
                                                const firstExecution = newTC.executions[0];
                                                setTestCases([...testCases, newTC]);
                                                setActiveTestCase(newTC.id);
                                                setActiveExecution(firstExecution?.id);
                                            }}
                                            className="w-full px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 mb-2 text-sm"
                                        >
                                            <Icon name="plus" /> New Test Case
                                        </button>
                                        <div className="space-y-1">
                                            {testCases.map(tc => (
                                                <div key={tc.id}>
                                                    <div
                                                        onClick={() => {
                                                            setActiveTestCase(tc.id);
                                                            if (tc.executions.length > 0) {
                                                                setActiveExecution(tc.executions[0].id);
                                                            }
                                                        }}
                                                        className={`px-3 py-2 rounded cursor-pointer text-sm truncate ${
                                                            activeTestCase === tc.id ? 'bg-blue-100 font-semibold' : 'hover:bg-gray-100'
                                                        }`}
                                                        title={tc.name}
                                                    >
                                                        {tc.name}
                                                    </div>
                                                    {activeTestCase === tc.id && (
                                                        <div className="ml-4 mt-1 space-y-1">
                                                            {tc.executions.map(ex => (
                                                                <div
                                                                    key={ex.id}
                                                                    onClick={() => setActiveExecution(ex.id)}
                                                                    className={`px-2 py-1 rounded cursor-pointer text-xs truncate ${
                                                                        activeExecution === ex.id ? 'bg-green-100 font-medium' : 'hover:bg-gray-50'
                                                                    }`}
                                                                    title={ex.name}
                                                                >
                                                                    {ex.name}
                                                                </div>
                                                            ))}
                                                            <button
                                                                onClick={() => {
                                                                    const templateId = tc.requirementTemplateId;
                                                                    const templateConfig = ensureTemplateConfig(templateId);
                                                                    const newEx = createNewExecution(tc, templateConfig, templateId);
                                                                    tc.executions.push(newEx);
                                                                    setTestCases([...testCases]);
                                                                    setActiveExecution(newEx.id);
                                                                }}
                                                                className="w-full px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700 text-xs"
                                                            >
                                                                + New Execution
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Main View */}
                        <div className="flex-1">
                            {view === 'execution' && renderExecutionView()}
                            {view === 'comparison' && renderComparisonView()}
                            {view === 'traceability' && renderTraceabilityView()}
                            {view === 'report' && renderReportView()}
                            {view === 'defects' && renderDefectView()}
                        </div>
                    </div>

                    {renderImportModal()}

                    <input
                        ref={importRef}
                        type="file"
                        accept=".csv,.json"
                        onChange={handleFileImport}
                        className="hidden"
                    />
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<LatencyTester />);
    </script>
</body>
</html>
