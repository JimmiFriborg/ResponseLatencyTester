<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardware Latency Tester v3.9 Release Candidate 3</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React and Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="js/session-diff.js"></script>
    <script type="text/babel" data-presets="env,react" src="js/compare-sessions-panel.jsx"></script>

    <style>
        .row-pass { background-color: rgba(34, 197, 94, 0.1); }
        .row-fail { background-color: rgba(239, 68, 68, 0.1); }
        .row-error { background-color: rgba(251, 191, 36, 0.1); }
        .row-excluded { background-color: rgba(156, 163, 175, 0.1); }
        @media print {
            .no-print { display: none !important; }
            body { background: white; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef, useMemo } = React;
        const sessionDiffUtils = window.LatencySessionDiff || {};
        const encodeExecutionKey = sessionDiffUtils.encodeExecutionKey || ((testCaseId, executionId) => `${testCaseId}::${executionId}`);
        const decodeExecutionKey = sessionDiffUtils.decodeExecutionKey || ((value) => {
            if (!value) return null;
            const [testCaseId, executionId] = value.split('::');
            if (!testCaseId || !executionId) return null;
            return { testCaseId, executionId };
        });
        const computeSessionDiffData = sessionDiffUtils.computeSessionDiffData || (() => null);
        const deriveSessionDiffStatus = sessionDiffUtils.deriveSessionDiffStatus || (() => ({ status: 'idle', message: 'Session diff helpers unavailable.' }));
        const CompareSessionsSummary = window.CompareSessionsSummary;

        const RELEASE_VERSION = 'v3.9 RC3';
        const DEFECT_REGISTER_FILE = 'v3.9-rc3-defects.json';
        const DEFECT_EXPORT_FILENAME = 'v3.9-rc3-defects.json';

        const AXIS_KEYS = ['X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-'];
        const AXES = ['X', 'Y', 'Z'];
        const DISTANCE_AXES = ['X', 'Y', 'Z'];
        const DATASET_SOURCE_LABELS = {
            'manual-entry': 'Manual Session',
            'manual-import': 'Manual Import',
            'automation-report': 'Automation Report'
        };
        const COMPARISON_STORAGE_KEY = 'latencyTesterComparisonQueue';
        const AVAILABLE_VIEWS = ['execution', 'hardware', 'comparison', 'traceability', 'report', 'defects', 'requirements'];

        const deriveInitialView = () => {
            if (typeof window === 'undefined') return 'execution';
            const hash = window.location.hash?.replace('#', '') || '';
            return AVAILABLE_VIEWS.includes(hash) ? hash : 'execution';
        };

        const trackAnalyticsEvent = (eventName, payload = {}) => {
            try {
                const event = {
                    event: `latencyTester:${eventName}`,
                    timestamp: new Date().toISOString(),
                    ...payload
                };
                if (window?.dataLayer && typeof window.dataLayer.push === 'function') {
                    window.dataLayer.push(event);
                }
                console.debug('[analytics]', event);
            } catch (error) {
                console.warn('Analytics tracking failed', error);
            }
        };

        const safeLocalStorageGet = (key) => {
            try {
                return window?.localStorage?.getItem(key) || null;
            } catch (_err) {
                return null;
            }
        };

        const safeLocalStorageSet = (key, value) => {
            try {
                window?.localStorage?.setItem(key, value);
            } catch (_err) {
                // Ignore storage errors (e.g., private mode)
            }
        };

        const normalizeComparisonEntry = (entry) => {
            if (!entry || !entry.testCaseId || !entry.executionId) {
                return null;
            }
            const axisKeys = Array.isArray(entry.axisKeys)
                ? entry.axisKeys.filter(Boolean)
                : (entry.axisKey ? [entry.axisKey] : []);
            return {
                key: entry.key || `${entry.testCaseId}-${entry.executionId}`,
                testCaseId: entry.testCaseId,
                executionId: entry.executionId,
                axisKeys: Array.from(new Set(axisKeys))
            };
        };

        const loadComparisonQueue = () => {
            if (typeof window === 'undefined') return [];
            const stored = safeLocalStorageGet(COMPARISON_STORAGE_KEY);
            if (!stored) return [];
            try {
                const parsed = JSON.parse(stored);
                if (!Array.isArray(parsed)) return [];
                return parsed
                    .map(normalizeComparisonEntry)
                    .filter(Boolean);
            } catch (_err) {
                return [];
            }
        };

        const persistComparisonQueue = (entries) => {
            if (typeof window === 'undefined') return;
            safeLocalStorageSet(COMPARISON_STORAGE_KEY, JSON.stringify(entries));
        };

        const getComparableAxisOptions = (execution) => {
            if (!execution?.timestamps) return [];
            const counts = execution.timestamps.reduce((acc, ts) => {
                if (ts.isError || ts.latencyMs == null || ts.excludeFromStats) return acc;
                if (!ts.axis || !ts.direction) return acc;
                const axisKey = ts.axis + ts.direction;
                if (!AXIS_KEYS.includes(axisKey)) return acc;
                acc[axisKey] = (acc[axisKey] || 0) + 1;
                return acc;
            }, {});
            return Object.entries(counts)
                .map(([key, count]) => ({ key, count }))
                .sort((a, b) => a.key.localeCompare(b.key));
        };

        const getComparisonAxisOptions = (entries = []) => {
            const axisSet = new Set();
            entries.forEach(entry => {
                (entry?.axisKeys || []).forEach(axisKey => {
                    if (axisKey) {
                        axisSet.add(axisKey);
                    }
                });
            });
            return Array.from(axisSet).sort();
        };

        const flattenAxisComparisonEntries = (entries = []) => {
            const flattened = [];
            entries.forEach(entry => {
                (entry?.axisKeys || []).forEach(axisKey => {
                    flattened.push({
                        key: `${entry.key}-${axisKey}`,
                        axisKey,
                        testCaseId: entry.testCaseId,
                        executionId: entry.executionId
                    });
                });
            });
            return flattened;
        };
        const hasDistanceValue = (value) => value !== undefined && value !== null && value !== '';
        const DEFECT_STATUSES = ['Open', 'Investigating', 'In Progress', 'Blocked', 'Resolved'];
        const DEFECT_SEVERITIES = ['Low', 'Medium', 'High', 'Critical'];

        const createDefectRecord = (overrides = {}) => ({
            id: overrides.id || (Date.now().toString() + '_defect'),
            title: overrides.title || '',
            description: overrides.description || '',
            severity: overrides.severity || 'Medium',
            owner: overrides.owner || '',
            status: overrides.status || 'Open',
            lastUpdated: overrides.lastUpdated || new Date().toISOString()
        });

        const getDefaultEnvironment = () => ({
            name: '',
            location: '',
            owner: '',
            dut: '',
            notes: ''
        });

        const createHardwareItem = (overrides = {}) => ({
            id: overrides.id || (Date.now().toString() + Math.random()),
            type: overrides.type || '',
            version: overrides.version || '',
            revision: overrides.revision || '',
            serialNumber: overrides.serialNumber || '',
            name: overrides.name || '',
            notes: overrides.notes || ''
        });

        const getDefaultExecutionRequirements = () => ({
            enabled: false,
            maxLatency: 100,
            minRespondRanges: { X: 5, Y: 5, Z: 5 },
            mustNotRespondRanges: { X: 25, Y: 25, Z: 25 }
        });

        const mergeExecutionRequirements = (requirements = {}) => {
            const defaults = getDefaultExecutionRequirements();
            return {
                ...defaults,
                ...requirements,
                minRespondRanges: {
                    ...defaults.minRespondRanges,
                    ...(requirements?.minRespondRanges || {})
                },
                mustNotRespondRanges: {
                    ...defaults.mustNotRespondRanges,
                    ...(requirements?.mustNotRespondRanges || {})
                }
            };
        };

        const createRequirementTemplate = (overrides = {}) => ({
            id: overrides.id || (Date.now().toString() + '_req'),
            name: overrides.name || 'Requirement ' + new Date().toLocaleString(),
            description: overrides.description || '',
            config: mergeExecutionRequirements(overrides.config || {})
        });

        const convertLegacyRequirementsToConfig = (legacy = {}) => {
            const defaults = getDefaultExecutionRequirements();
            const base = mergeExecutionRequirements({
                enabled: legacy.enabled ?? defaults.enabled,
                maxLatency: legacy.maxLatency ?? defaults.maxLatency
            });
            const minRespondRanges = { ...base.minRespondRanges };
            const mustNotRespondRanges = { ...base.mustNotRespondRanges };
            AXES.forEach(axis => {
                const plusKey = axis + '+';
                const minusKey = axis + '-';
                const plusRange = legacy?.ranges?.[plusKey] || {};
                const minusRange = legacy?.ranges?.[minusKey] || {};
                minRespondRanges[axis] =
                    plusRange.minRespond ?? minusRange.minRespond ?? minRespondRanges[axis];
                mustNotRespondRanges[axis] =
                    plusRange.mustNotRespond ?? minusRange.mustNotRespond ?? mustNotRespondRanges[axis];
            });
            return {
                ...base,
                minRespondRanges,
                mustNotRespondRanges
            };
        };

        const normalizeDistances = (distances = {}) => {
            const normalized = {};
            DISTANCE_AXES.forEach(axis => {
                if (distances[axis] || distances[axis] === 0) {
                    normalized[axis] = distances[axis];
                    return;
                }
                const plusKey = axis + '+';
                const minusKey = axis + '-';
                if (distances[plusKey] || distances[plusKey] === 0) {
                    normalized[axis] = distances[plusKey];
                    return;
                }
                if (distances[minusKey] || distances[minusKey] === 0) {
                    normalized[axis] = distances[minusKey];
                }
            });
            return normalized;
        };

        const normalizeHardwareList = (hardware = []) => {
            return hardware.map(item => createHardwareItem(item));
        };

        const describeHardwarePreset = (hardware) => {
            if (!hardware) return 'Unnamed hardware';
            const segments = [];
            if (hardware.type) segments.push(hardware.type);
            if (hardware.name) segments.push(hardware.name);
            if (hardware.serialNumber) segments.push(`#${hardware.serialNumber}`);
            return segments.length > 0 ? segments.join(' Â· ') : 'Unnamed hardware';
        };

        const LatencyTester = () => {
            // State management
            const [testCases, setTestCases] = useState([]);
            const [activeTestCase, setActiveTestCase] = useState(null);
            const [activeExecution, setActiveExecution] = useState(null);
            const [comparisonExecutions, setComparisonExecutions] = useState(() => loadComparisonQueue());
            const [selectedComparisonAxis, setSelectedComparisonAxis] = useState(null);
            const [view, setView] = useState(() => deriveInitialView()); // execution, hardware, comparison, report, traceability, defects, requirements
            const [showPassFailHighlight, setShowPassFailHighlight] = useState(true);
            const [selectedForReport, setSelectedForReport] = useState([]);
            const [requirementTemplates, setRequirementTemplates] = useState(() => [
                createRequirementTemplate({ name: 'Default Requirements' })
            ]);
            const [hardwareLibrary, setHardwareLibrary] = useState(() => [
                createHardwareItem({
                    id: 'hardware-library-default',
                    type: 'DUT',
                    name: 'Reference Controller',
                    notes: 'Update serial and build info before attaching to runs.'
                })
            ]);
            const [hasUnsavedTemplateChanges, setHasUnsavedTemplateChanges] = useState(false);
            const [traceabilityFilter, setTraceabilityFilter] = useState('');
            const [importDialog, setImportDialog] = useState(null);
            const [defects, setDefects] = useState([]);
            const [defectFilter, setDefectFilter] = useState('');
            const [defectStatusFilter, setDefectStatusFilter] = useState('all');
            const [defectSeverityFilter, setDefectSeverityFilter] = useState('all');
            const [importHardwareLibrarySelection, setImportHardwareLibrarySelection] = useState('');
            const [executionHardwareLibrarySelection, setExecutionHardwareLibrarySelection] = useState('');
            const [sessionDiffConfig, setSessionDiffConfig] = useState({ baseline: null, candidate: null });
            const [sessionDiffState, setSessionDiffState] = useState({
                status: 'idle',
                message: 'Select a baseline and candidate dataset to calculate differences.'
            });
            const [compareSessionsDialog, setCompareSessionsDialog] = useState(null);
            const [diffAnnotations, setDiffAnnotations] = useState({});
            const [copyDiffStatus, setCopyDiffStatus] = useState('');
            const [axisSelectionPanel, setAxisSelectionPanel] = useState(null);
            const [comparisonQueueStatus, setComparisonQueueStatus] = useState('');

            const importRef = useRef(null);
            const copyStatusTimeoutRef = useRef(null);
            const comparisonStatusTimeoutRef = useRef(null);

            const executionExists = (ref) => {
                if (!ref) return false;
                const tc = testCases.find(testCase => testCase.id === ref.testCaseId);
                if (!tc) return false;
                return (tc.executions || []).some(ex => ex.id === ref.executionId);
            };

            const describeDatasetSource = (source) => DATASET_SOURCE_LABELS[source] || DATASET_SOURCE_LABELS['manual-entry'];

            useEffect(() => {
                return () => {
                    if (copyStatusTimeoutRef.current) {
                        clearTimeout(copyStatusTimeoutRef.current);
                    }
                    if (comparisonStatusTimeoutRef.current) {
                        clearTimeout(comparisonStatusTimeoutRef.current);
                    }
                };
            }, []);

            useEffect(() => {
                setSessionDiffConfig(prev => {
                    const nextBaseline = prev.baseline && executionExists(prev.baseline) ? prev.baseline : null;
                    const nextCandidate = prev.candidate && executionExists(prev.candidate) ? prev.candidate : null;
                    if (nextBaseline === prev.baseline && nextCandidate === prev.candidate) {
                        return prev;
                    }
                    return { baseline: nextBaseline, candidate: nextCandidate };
                });
            }, [testCases]);

            useEffect(() => {
                fetch(DEFECT_REGISTER_FILE)
                    .then(response => response.ok ? response.json() : null)
                    .then(data => {
                        if (data && Array.isArray(data.defects)) {
                            setDefects(data.defects.map(defect => createDefectRecord(defect)));
                        }
                    })
                    .catch(() => {
                        // When running from file:// the fetch will fail silently.
                    });
            }, []);

            useEffect(() => {
                persistComparisonQueue(comparisonExecutions);
            }, [comparisonExecutions]);

            useEffect(() => {
                setSelectedComparisonAxis(prev => {
                    const axisOptions = getComparisonAxisOptions(comparisonExecutions);
                    if (prev && axisOptions.includes(prev)) {
                        return prev;
                    }
                    return axisOptions[0] || null;
                });
            }, [comparisonExecutions]);

            useEffect(() => {
                const handleHashChange = () => {
                    const nextView = deriveInitialView();
                    setView(prev => prev === nextView ? prev : nextView);
                };
                window.addEventListener('hashchange', handleHashChange);
                return () => window.removeEventListener('hashchange', handleHashChange);
            }, []);

            const executionOptions = useMemo(() => {
                const entries = [];
                testCases.forEach(tc => {
                    (tc.executions || []).forEach(ex => {
                        entries.push({
                            value: encodeExecutionKey(tc.id, ex.id),
                            testCaseId: tc.id,
                            executionId: ex.id,
                            label: `${tc.name} Â· ${ex.name}`,
                            datasetSource: ex.datasetSource || 'manual-entry',
                            timestampCount: (ex.timestamps || []).length,
                            fps: ex.fps,
                            hardwareCount: (ex.hardware || []).length
                        });
                    });
                });
                return entries.sort((a, b) => a.label.localeCompare(b.label));
            }, [testCases]);

            const getExecutionSummaryForDiff = (ref) => {
                if (!ref) return null;
                const tc = testCases.find(testCase => testCase.id === ref.testCaseId);
                if (!tc) return null;
                const execution = (tc.executions || []).find(ex => ex.id === ref.executionId);
                if (!execution) return null;
                const requirements = mergeExecutionRequirements(execution.requirements);
                const grouped = groupByAxis(execution.timestamps || []);
                const axisStats = {};
                Object.entries(grouped).forEach(([axisKey, axisTimestamps]) => {
                    if (axisKey === UNGROUPED_BUCKET) return;
                    const axis = axisKey[0];
                    const direction = axisKey[1];
                    axisStats[axisKey] = getAxisStatistics(axisTimestamps, axis, direction, requirements);
                });
                const parsedFps = Number.parseFloat(execution.fps);
                const fpsValue = Number.isFinite(parsedFps) ? parsedFps : null;
                const hardwareSummary = (execution.hardware || [])
                    .map(hw => describeHardwarePreset(hw))
                    .join('; ') || 'No hardware linked';
                return {
                    testCaseId: tc.id,
                    executionId: execution.id,
                    testCaseName: tc.name,
                    executionName: execution.name,
                    fps: fpsValue,
                    datasetSource: execution.datasetSource || 'manual-entry',
                    hardwareSummary,
                    axisStats
                };
            };

            const sessionDiffData = useMemo(() => {
                if (!sessionDiffConfig.baseline || !sessionDiffConfig.candidate) return null;
                const baseline = getExecutionSummaryForDiff(sessionDiffConfig.baseline);
                const candidate = getExecutionSummaryForDiff(sessionDiffConfig.candidate);
                if (!baseline || !candidate) return null;
                const axisKeys = Array.from(new Set([
                    ...Object.keys(baseline.axisStats || {}),
                    ...Object.keys(candidate.axisStats || {})
                ]));
                return computeSessionDiffData({
                    baseline,
                    candidate,
                    axisKeys,
                    axes: AXES
                });
            }, [sessionDiffConfig, testCases]);

            const sessionDiffAxisMap = sessionDiffData?.axisMap || {};
            const sessionDiffAxisAggregate = sessionDiffData?.axisAggregate || {};

            useEffect(() => {
                setSessionDiffState(deriveSessionDiffStatus({
                    selection: sessionDiffConfig,
                    diffData: sessionDiffData,
                    baselineAvailable: executionExists(sessionDiffConfig.baseline),
                    candidateAvailable: executionExists(sessionDiffConfig.candidate),
                    hasExecutions: executionOptions.length > 0
                }));
            }, [sessionDiffConfig, sessionDiffData, executionOptions]);

            const getRequirementTemplateById = (templateId) =>
                requirementTemplates.find(template => template.id === templateId);

            const markTemplatesDirty = () => setHasUnsavedTemplateChanges(true);
            const clearTemplateDirtyState = () => setHasUnsavedTemplateChanges(false);

            const confirmTemplateNavigation = () => {
                if (!hasUnsavedTemplateChanges) {
                    return true;
                }
                const proceed = window.confirm('You have unsaved requirement template edits. They will be saved automatically before continuing. Continue?');
                if (proceed) {
                    clearTemplateDirtyState();
                }
                return proceed;
            };

            const runWithTemplateGuard = (action) => {
                if (view !== 'requirements') {
                    action();
                    return true;
                }
                if (!confirmTemplateNavigation()) {
                    return false;
                }
                action();
                return true;
            };

            const changeView = (nextView) => {
                if (!AVAILABLE_VIEWS.includes(nextView)) return;
                if (view === 'requirements' && nextView !== 'requirements') {
                    if (!confirmTemplateNavigation()) {
                        return;
                    }
                }
                if (typeof window !== 'undefined') {
                    window.location.hash = `#${nextView}`;
                }
                setView(nextView);
            };

            const addHardwareLibraryItem = () => {
                const preset = createHardwareItem({
                    name: `Hardware Preset ${hardwareLibrary.length + 1}`
                });
                setHardwareLibrary(prev => [...prev, preset]);
                return preset;
            };

            const updateHardwareLibraryField = (presetId, field, value) => {
                setHardwareLibrary(prev => prev.map(item =>
                    item.id === presetId ? { ...item, [field]: value } : item
                ));
            };

            const deleteHardwareLibraryItem = (presetId) => {
                setHardwareLibrary(prev => prev.filter(item => item.id !== presetId));
                setImportHardwareLibrarySelection(prev => prev === presetId ? '' : prev);
                setExecutionHardwareLibrarySelection(prev => prev === presetId ? '' : prev);
            };

            const instantiateHardwareFromLibrary = (presetId) => {
                const preset = hardwareLibrary.find(item => item.id === presetId);
                if (!preset) return null;
                const { id: _omit, ...rest } = preset;
                return createHardwareItem(rest);
            };

            const addHardwarePresetToExecution = (presetId, executionId = activeExecution) => {
                if (!presetId || !executionId || !activeTestCase) return;
                const hardware = instantiateHardwareFromLibrary(presetId);
                if (!hardware) return;
                setTestCases(prev => prev.map(tc => {
                    if (tc.id !== activeTestCase) {
                        return tc;
                    }
                    return {
                        ...tc,
                        executions: tc.executions.map(ex =>
                            ex.id === executionId
                                ? { ...ex, hardware: [...(ex.hardware || []), hardware] }
                                : ex
                        )
                    };
                }));
                setExecutionHardwareLibrarySelection('');
            };

            const addHardwarePresetToImport = (presetId) => {
                if (!presetId) return;
                const hardware = instantiateHardwareFromLibrary(presetId);
                if (!hardware) return;
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: [...prev.form.hardware, hardware]
                    }
                }) : prev);
                setImportHardwareLibrarySelection('');
            };

            const cloneTemplateConfig = (templateId) => {
                const template = getRequirementTemplateById(templateId);
                return template ? mergeExecutionRequirements(template.config) : null;
            };

            const ensureTemplateConfig = (templateId) =>
                cloneTemplateConfig(templateId) || getDefaultExecutionRequirements();

            const syncTemplateToExecutions = (templateId, config) => {
                if (!templateId) return;
                setTestCases(prev => prev.map(tc => {
                    if (!tc.executions || tc.executions.length === 0) {
                        return tc;
                    }
                    const needsUpdate = tc.executions.some(ex => ex.requirementTemplateId === templateId);
                    if (!needsUpdate) {
                        return tc;
                    }
                    return {
                        ...tc,
                        executions: tc.executions.map(ex =>
                            ex.requirementTemplateId === templateId
                                ? { ...ex, requirements: mergeExecutionRequirements(config) }
                                : ex
                        )
                    };
                }));
            };

            const applyRequirementConfigChange = (config, field, value) => {
                const merged = mergeExecutionRequirements(config);
                if (field === 'minRespondRanges' || field === 'mustNotRespondRanges') {
                    return {
                        ...merged,
                        [field]: {
                            ...merged[field],
                            ...value
                        }
                    };
                }
                if (field === 'enabled') {
                    return {
                        ...merged,
                        enabled: value
                    };
                }
                return {
                    ...merged,
                    [field]: value
                };
            };

            const addRequirementTemplate = () => {
                const template = createRequirementTemplate({
                    name: `Requirement ${requirementTemplates.length + 1}`
                });
                setRequirementTemplates(prev => [...prev, template]);
                markTemplatesDirty();
                return template;
            };

            const deleteRequirementTemplate = (templateId) => {
                if (requirementTemplates.length <= 1) {
                    alert('At least one requirement template must remain.');
                    return;
                }
                setRequirementTemplates(prev => prev.filter(template => template.id !== templateId));
                markTemplatesDirty();
                setTestCases(prev => prev.map(tc => ({
                    ...tc,
                    requirementTemplateId: tc.requirementTemplateId === templateId ? null : tc.requirementTemplateId,
                    executions: tc.executions.map(ex =>
                        ex.requirementTemplateId === templateId
                            ? { ...ex, requirementTemplateId: null }
                            : ex
                    )
                })));
            };

            const updateRequirementTemplateDetails = (templateId, field, value) => {
                markTemplatesDirty();
                setRequirementTemplates(prev => prev.map(template =>
                    template.id === templateId ? { ...template, [field]: value } : template
                ));
            };

            const updateRequirementTemplateConfig = (templateId, field, value) => {
                const template = getRequirementTemplateById(templateId);
                if (!template) return;
                const nextConfig = applyRequirementConfigChange(template.config, field, value);
                markTemplatesDirty();
                setRequirementTemplates(prev => prev.map(item =>
                    item.id === templateId ? { ...item, config: nextConfig } : item
                ));
                syncTemplateToExecutions(templateId, nextConfig);
            };

            const applyTemplateToExecution = (executionId, templateId) => {
                if (!templateId) return;
                const templateConfig = ensureTemplateConfig(templateId);
                setTestCases(prev => prev.map(tc => {
                    if (tc.id !== activeTestCase) return tc;
                    return {
                        ...tc,
                        executions: tc.executions.map(ex =>
                            ex.id === executionId
                                ? {
                                    ...ex,
                                    requirementTemplateId: templateId,
                                    requirements: mergeExecutionRequirements(templateConfig)
                                }
                                : ex
                        )
                    };
                }));
            };

            const applyTemplateToAllExecutions = (templateId) => {
                if (!templateId) return;
                const templateConfig = ensureTemplateConfig(templateId);
                setTestCases(prev => prev.map(tc => {
                    if (tc.id !== activeTestCase) return tc;
                    return {
                        ...tc,
                        executions: tc.executions.map(ex => ({
                            ...ex,
                            requirementTemplateId: templateId,
                            requirements: mergeExecutionRequirements(templateConfig)
                        }))
                    };
                }));
            };

            const updateTestCaseTemplateSelection = (templateId) => {
                setTestCases(prev => prev.map(tc =>
                    tc.id === activeTestCase ? { ...tc, requirementTemplateId: templateId } : tc
                ));
            };

            const getRequirementConfigForTestCase = (testCase) => {
                if (!testCase) return null;
                const template = getRequirementTemplateById(testCase.requirementTemplateId);
                if (template) {
                    return mergeExecutionRequirements(template.config);
                }
                const firstExecution = testCase.executions?.[0];
                if (firstExecution) {
                    return mergeExecutionRequirements(firstExecution.requirements);
                }
                return null;
            };

            // Icons
            const Icon = ({ name }) => {
                const icons = {
                    'plus': 'â•', 'trash-2': 'ğŸ—‘ï¸', 'download': 'â¬‡ï¸', 'upload': 'â¬†ï¸',
                    'edit': 'âœï¸', 'save': 'ğŸ’¾', 'x': 'âŒ', 'check': 'âœ…',
                    'bar-chart': 'ğŸ“Š', 'settings': 'âš™ï¸', 'file-text': 'ğŸ“„',
                    'eye': 'ğŸ‘ï¸', 'eye-off': 'ğŸ‘ï¸â€ğŸ—¨ï¸', 'git-compare': 'ğŸ”„',
                    'hard-drive': 'ğŸ’½', 'star': 'â­', 'star-off': 'â˜†',
                    'alert-triangle': 'âš ï¸', 'copy': 'ğŸ“‹', 'pin': 'ğŸ“Œ', 'link': 'ğŸ”—'
                };
                return <span>{icons[name] || 'â€¢'}</span>;
            };

            // Parse timecode with FPS defaulting
        const parseTimecode = (timecode, fps = 30) => {
            if (!timecode) return 0;
            const safeFps = (typeof fps === 'number' ? fps : parseFloat(fps)) || 30;
            const sanitized = timecode.toString().trim();
            if (!sanitized) return 0;

            const parts = sanitized.split(':');

            if (parts.length === 4) {
                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                const seconds = parseInt(parts[2]) || 0;
                const frames = parseInt(parts[3]) || 0;
                const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
                const frameTime = frames / safeFps;
                return (totalSeconds + frameTime) * 1000;
            }

            if (parts.length === 3) {
                const hoursOrMinutes = parseInt(parts[0]) || 0;
                const minutesOrSeconds = parseInt(parts[1]) || 0;
                const frames = parseInt(parts[2]) || 0;
                // Treat the three-part form as MM:SS:FF with an implied hour of 0.
                const totalSeconds = (hoursOrMinutes * 60) + minutesOrSeconds;
                const frameTime = frames / safeFps;
                return (totalSeconds + frameTime) * 1000;
            }

            if (parts.length === 2) {
                const minutes = parseInt(parts[0]) || 0;
                const seconds = parseFloat(parts[1]) || 0;
                return ((minutes * 60) + seconds) * 1000;
            }

            const numericValue = parseFloat(sanitized);
            if (!isNaN(numericValue)) {
                return numericValue * 1000;
            }

            return 0;
        };

        const msToSecondsFormat = (ms) => (ms / 1000).toFixed(3);
        const formatMsToTime = (ms) => (!ms && ms !== 0) ? '-' : (ms / 1000).toFixed(3) + 's';
        const formatDeltaMs = (value, suffix = 'ms') => {
            if (value === null || value === undefined || Number.isNaN(value)) {
                return 'â€”';
            }
            const formatted = Number(value).toFixed(2);
            const numeric = Number(value);
            const prefix = numeric > 0 ? '+' : '';
            return `${prefix}${formatted}${suffix}`;
        };
        const getDeltaBadgeClasses = (value) => {
            if (value === null || value === undefined || Number.isNaN(value)) {
                return 'bg-gray-100 text-gray-600';
            }
            if (value < 0) {
                return 'bg-emerald-100 text-emerald-800';
            }
            if (value > 0) {
                return 'bg-rose-100 text-rose-700';
            }
            return 'bg-gray-200 text-gray-700';
        };
        const computeFpsDelta = (baselineFps, candidateFps) => {
            const base = Number.parseFloat(baselineFps);
            const cand = Number.parseFloat(candidateFps);
            if (!Number.isFinite(base) || !Number.isFinite(cand)) {
                return null;
            }
            return cand - base;
        };

        const recalculateLatenciesForFps = (timestamps = [], fpsValue) => {
            const numericFps = parseFloat(fpsValue);
            if (!numericFps || !isFinite(numericFps) || numericFps <= 0) {
                return timestamps;
            }

            return timestamps.map(ts => {
                if (!ts.recordIn || !ts.pairedRecordIn || ts.isError) {
                    return ts;
                }

                const startMs = parseTimecode(ts.recordIn, numericFps);
                const endMs = parseTimecode(ts.pairedRecordIn, numericFps);

                if (!isFinite(startMs) || !isFinite(endMs) || endMs < startMs) {
                    return ts;
                }

                const latencyMs = endMs - startMs;
                return {
                    ...ts,
                    latencyMs,
                    latency: msToSecondsFormat(latencyMs),
                    calculationExplained: `${ts.recordIn} â†’ ${ts.pairedRecordIn} @ ${numericFps}fps = ${msToSecondsFormat(latencyMs)}`
                };
            });
        };

            // Parse marker naming
            function parseMarkerName(markerName) {
                const yellowRegex = /AB(\d+)\s+(.+?)\s+Tag([\d.]+)\s*\(([XYZ])([+-])\)/i;
                const yellowMatch = markerName.match(yellowRegex);

                if (yellowMatch) {
                    return {
                        type: 'identifier',
                        abNumber: 'AB' + yellowMatch[1],
                        descriptor: yellowMatch[2],
                        tagVersion: yellowMatch[3],
                        axis: yellowMatch[4].toUpperCase(),
                        direction: yellowMatch[5]
                    };
                }

                // Action marker: TagOn #1, TagOn.Activation #1
                const actionRegex = /Tag(\w+)(?:\.(\w+))?\s+#(\d+)/i;
                const actionMatch = markerName.match(actionRegex);

                if (actionMatch) {
                    return {
                        type: 'action',
                        tagAction: actionMatch[1],
                        subAction: actionMatch[2] || '',
                        testRun: actionMatch[3]
                    };
                }

                // Error marker: Error-start #1, Error-end #1
                const errorRegex = /Error-(start|end)\s+#(\d+)/i;
                const errorMatch = markerName.match(errorRegex);

                if (errorMatch) {
                    return {
                        type: 'error',
                        errorType: errorMatch[1],
                        errorNumber: errorMatch[2]
                    };
                }

                return null;
            }

            // Parse CSV with FPS auto-detection
            const parseDavinciCSV = (csvText, filename) => {
                console.log('Parsing CSV: ' + filename);
                const lines = csvText.split('\n').filter(line => line.trim());
                if (lines.length < 2) return null;

                const parseCSVLine = (line) => {
                    const result = [];
                    let current = '';
                    let inQuotes = false;

                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    result.push(current.trim());
                    return result;
                };

                // Parse all data rows
                const dataRows = [];
                let detectedFPS = 30; // Default FPS
                let fpsSource = 'default';

                for (let i = 1; i < lines.length; i++) {
                    const row = parseCSVLine(lines[i]);
                    if (row.length > 20) {
                        const rowFPS = parseFloat(row[17]);
                        if (rowFPS > 0) {
                            detectedFPS = rowFPS;
                            fpsSource = 'csv';
                        }
                        dataRows.push({
                            recordIn: row[9] || '',
                            color: row[19] || '',
                            notes: row[20] || ''
                        });
                    }
                }

                console.log('Detected FPS: ' + detectedFPS);

                const timestamps = [];
                const pendingMarkers = {};
                const errorGroups = {};
                let currentMetadata = {};
                const axesFound = new Set();
                const rangesDetected = {};

                dataRows.forEach((row, index) => {
                    const color = row.color.toLowerCase();
                    const notes = row.notes;
                    const timeMs = parseTimecode(row.recordIn, detectedFPS);
                    const timeStr = msToSecondsFormat(timeMs);

                    // Skip blue markers (placeholders)
                    if (color === 'blue') return;

                    // Current axis context
                    const currentAxis = currentMetadata?.axis || '';
                    const currentDirection = currentMetadata?.direction || '';

                    // Handle red markers (error zones) with grouping
                    if (color === 'red') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'error') {
                            const errorNum = parsed.errorNumber;

                            if (!errorGroups[errorNum]) {
                                errorGroups[errorNum] = { start: null, end: null };
                            }

                            if (parsed.errorType === 'start') {
                                errorGroups[errorNum].start = {
                                    time: timeStr,
                                    recordIn: row.recordIn,
                                    timeMs: timeMs
                                };
                            } else {
                                errorGroups[errorNum].end = {
                                    time: timeStr,
                                    recordIn: row.recordIn,
                                    timeMs: timeMs
                                };
                            }

                            if (errorGroups[errorNum].start && errorGroups[errorNum].end) {
                                const start = errorGroups[errorNum].start;
                                const end = errorGroups[errorNum].end;
                                const duration = end.timeMs - start.timeMs;

                                timestamps.push({
                                    id: Date.now().toString() + Math.random(),
                                    time: start.time,
                                    recordIn: start.recordIn,
                                    label: 'Error',
                                    note: 'Error #' + errorNum + ' (Duration: ' + msToSecondsFormat(duration) + 's)',
                                    userNotes: '',
                                    stage: '',
                                    axis: currentAxis,
                                    direction: currentDirection,
                                    latencyMs: null,
                                    excludeFromStats: true,
                                    isError: true,
                                    isMarked: false,
                                    errorNumber: errorNum,
                                    errorDuration: duration
                                });
                            }
                        }
                        return;
                    }

                    // Handle yellow markers (axis identifiers)
                    if (color === 'yellow') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'identifier') {
                            currentMetadata = parsed;
                            const axisKey = parsed.axis + parsed.direction;
                            axesFound.add(axisKey);

                            const rangeMatch = notes.match(/(\d+)\s*mm/i);
                            rangesDetected[axisKey] = rangeMatch ? parseInt(rangeMatch[1]) : null;
                        }
                    }
                    // Green markers (TagOn trigger)
                    else if (color === 'green') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'action') {
                            const key = 'tagOn-' + parsed.testRun;
                            pendingMarkers[key] = {
                                time: timeStr,
                                recordIn: row.recordIn,
                                timeMs: timeMs,
                                testRun: parsed.testRun,
                                notes: notes,
                                metadata: currentMetadata
                            };
                        }
                    }
                    // Handle pink markers (TagOn activation)
                    else if (color === 'pink') {
                        const tagOnKeys = Object.keys(pendingMarkers).filter(k => k.startsWith('tagOn-'));
                        if (tagOnKeys.length > 0) {
                            const lastKey = tagOnKeys[tagOnKeys.length - 1];
                            const tagOnMarker = pendingMarkers[lastKey];
                            delete pendingMarkers[lastKey];

                            const latency = timeMs - tagOnMarker.timeMs;

                            timestamps.push({
                                id: Date.now().toString() + Math.random(),
                                time: tagOnMarker.time,
                                recordIn: tagOnMarker.recordIn,
                                label: 'TagOn',
                                note: tagOnMarker.notes + ' â†’ ' + notes,
                                userNotes: '',
                                stage: 'Tag' + (tagOnMarker.metadata?.tagVersion || '1.0') + ' Run#' + tagOnMarker.testRun,
                                pairedTime: timeStr,
                                pairedRecordIn: row.recordIn,
                                latency: msToSecondsFormat(latency),
                                latencyMs: latency,
                                axis: tagOnMarker.metadata?.axis || '',
                                direction: tagOnMarker.metadata?.direction || '',
                                abNumber: tagOnMarker.metadata?.abNumber || '',
                                tagVersion: tagOnMarker.metadata?.tagVersion || '',
                                testRun: tagOnMarker.testRun,
                                excludeFromStats: false,
                                calculationExplained: `${tagOnMarker.recordIn} â†’ ${row.recordIn} @ ${detectedFPS}fps = ${msToSecondsFormat(latency)}`,
                                isError: false,
                                isMarked: false
                            });
                        }
                    }
                    // Handle cyan markers (TagOff trigger)
                    else if (color === 'cyan') {
                        const parsed = parseMarkerName(notes);
                        if (parsed && parsed.type === 'action') {
                            const key = 'tagOff-' + parsed.testRun;
                            pendingMarkers[key] = {
                                time: timeStr,
                                recordIn: row.recordIn,
                                timeMs: timeMs,
                                testRun: parsed.testRun,
                                notes: notes,
                                metadata: currentMetadata
                            };
                        }
                    }
                    // Handle lemon/lime markers (TagOff activation)
                    else if (color === 'lemon' || color === 'lime') {
                        const tagOffKeys = Object.keys(pendingMarkers).filter(k => k.startsWith('tagOff-'));
                        if (tagOffKeys.length > 0) {
                            const lastKey = tagOffKeys[tagOffKeys.length - 1];
                            const tagOffMarker = pendingMarkers[lastKey];
                            delete pendingMarkers[lastKey];

                            const latency = timeMs - tagOffMarker.timeMs;

                            timestamps.push({
                                id: Date.now().toString() + Math.random(),
                                time: tagOffMarker.time,
                                recordIn: tagOffMarker.recordIn,
                                label: 'TagOff',
                                note: tagOffMarker.notes + ' â†’ ' + notes,
                                userNotes: '',
                                stage: 'Tag' + (tagOffMarker.metadata?.tagVersion || '1.0') + ' Run#' + tagOffMarker.testRun,
                                pairedTime: timeStr,
                                pairedRecordIn: row.recordIn,
                                latency: msToSecondsFormat(latency),
                                latencyMs: latency,
                                axis: tagOffMarker.metadata?.axis || '',
                                direction: tagOffMarker.metadata?.direction || '',
                                abNumber: tagOffMarker.metadata?.abNumber || '',
                                tagVersion: tagOffMarker.metadata?.tagVersion || '',
                                testRun: tagOffMarker.testRun,
                                excludeFromStats: false,
                                calculationExplained: `${tagOffMarker.recordIn} â†’ ${row.recordIn} @ ${detectedFPS}fps = ${msToSecondsFormat(latency)}`,
                                isError: false,
                                isMarked: false
                            });
                        }
                    }
                });

                // Handle unmatched markers
                Object.values(pendingMarkers).forEach(marker => {
                    timestamps.push({
                        id: Date.now().toString() + Math.random(),
                        time: marker.time,
                        recordIn: marker.recordIn,
                        label: 'Error',
                        note: marker.notes + ' (UNMATCHED)',
                        userNotes: '',
                        stage: '',
                        axis: marker.metadata?.axis || '',
                        direction: marker.metadata?.direction || '',
                        latencyMs: null,
                        excludeFromStats: true,
                        isError: true,
                        isMarked: false
                    });
                });

                console.log('Parsed timestamps: ' + timestamps.length);
                console.log('Axes found: ' + Array.from(axesFound).join(', '));

                return {
                    timestamps,
                    metadata: currentMetadata,
                    axesFound: Array.from(axesFound),
                    rangesDetected,
                    filename,
                    fps: detectedFPS,
                    fpsSource
                };
            };

            const hydrateTestCases = (cases = [], templates = requirementTemplates, defaultDatasetSource = 'manual-entry') => {
                return cases.map(tc => {
                    const templateId = tc.requirementTemplateId || templates[0]?.id || null;
                    return {
                        ...tc,
                        requirementTemplateId: templateId,
                        environment: { ...getDefaultEnvironment(), ...(tc.environment || {}) },
                        distances: normalizeDistances(tc.distances || {}),
                        executions: (tc.executions || []).map(execution => ({
                            ...execution,
                            timestamps: (execution.timestamps || []).map(ts => ({
                                ...ts,
                                note: ts.note || '',
                                isMarked: Boolean(ts.isMarked)
                            })),
                            fps: execution.fps != null ? execution.fps : '',
                            fpsSource: execution.fpsSource || 'unknown',
                            datasetSource: execution.datasetSource || defaultDatasetSource,
                            requirements: mergeExecutionRequirements(execution.requirements),
                            requirementTemplateId: execution.requirementTemplateId || templateId,
                            hardware: normalizeHardwareList(execution.hardware || []),
                            notes: execution.notes || ''
                        }))
                    };
                });
            };

            // Statistics
            function getStatistics(timestamps, requirements = null) {
                const validTimestamps = timestamps.filter(ts =>
                    ts.latencyMs != null && !ts.excludeFromStats && !ts.isError
                );

                if (validTimestamps.length === 0) {
                    return { min: 0, max: 0, avg: 0, total: 0, passed: 0, failed: 0, passRate: 0 };
                }

                const values = validTimestamps.map(ts => ts.latencyMs);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;

                let passed = 0;
                let failed = 0;

                if (requirements && requirements.enabled) {
                    validTimestamps.forEach(ts => {
                        if (ts.latencyMs <= requirements.maxLatency) {
                            passed++;
                        } else {
                            failed++;
                        }
                    });
                }

                const passRate = validTimestamps.length > 0 ? (passed / validTimestamps.length) * 100 : 0;

                return { min, max, avg, total: validTimestamps.length, passed, failed, passRate };
            }

            function getAxisStatistics(timestamps, axis, direction, requirements = null) {
                const axisTimestamps = timestamps.filter(ts =>
                    ts.axis === axis && ts.direction === direction && !ts.isError
                );

                const validTimestamps = axisTimestamps.filter(ts =>
                    ts.latencyMs != null && !ts.excludeFromStats
                );

                if (validTimestamps.length === 0) {
                    return {
                        min: 0,
                        max: 0,
                        avg: 0,
                        total: 0,
                        passed: 0,
                        failed: 0,
                        passRate: 0,
                        errorCount: axisTimestamps.filter(ts => ts.isError).length
                    };
                }

                const values = validTimestamps.map(ts => ts.latencyMs);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;

                let passed = 0;
                let failed = 0;

                if (requirements && requirements.enabled) {
                    validTimestamps.forEach(ts => {
                        if (ts.latencyMs <= requirements.maxLatency) {
                            passed++;
                        } else {
                            failed++;
                        }
                    });
                }

                const passRate = validTimestamps.length > 0 ? (passed / validTimestamps.length) * 100 : 0;
                const errorCount = axisTimestamps.filter(ts => ts.isError).length;

                return { min, max, avg, total: validTimestamps.length, passed, failed, passRate, errorCount };
            }

            const UNGROUPED_BUCKET = 'Ungrouped';

            // Group by axis
            const groupByAxis = (timestamps) => {
                const groups = {};
                const insertionOrder = [];
                const ungrouped = [];

                timestamps.forEach(ts => {
                    if (ts.isError) return;

                    if (ts.axis && ts.direction) {
                        const key = ts.axis + ts.direction;
                        if (!groups[key]) {
                            groups[key] = [];
                            insertionOrder.push(key);
                        }
                        groups[key].push(ts);
                    } else {
                        ungrouped.push(ts);
                    }
                });

                const orderedGroups = {};
                insertionOrder.forEach(key => {
                    orderedGroups[key] = groups[key];
                });

                if (ungrouped.length > 0) {
                    orderedGroups[UNGROUPED_BUCKET] = ungrouped;
                }

                return orderedGroups;
            };

            // Create new execution
            const createNewExecution = (testCase = { executions: [] }, templateConfig = null, templateId = null) => ({
                id: Date.now().toString() + '_exec',
                name: 'Execution ' + ((testCase?.executions?.length || 0) + 1),
                timestamps: [],
                fps: '',
                fpsSource: 'unknown',
                datasetSource: 'manual-entry',
                requirements: mergeExecutionRequirements(templateConfig || getDefaultExecutionRequirements()),
                requirementTemplateId: templateId,
                notes: '',
                hardware: []
            });

            // Create new test case
            const createNewTestCase = () => {
                const defaultTemplateId = requirementTemplates[0]?.id || null;
                const defaultTemplateConfig = ensureTemplateConfig(defaultTemplateId);
                const testCase = {
                    id: Date.now().toString(),
                    name: 'Test Case ' + (testCases.length + 1),
                    metadata: {},
                    distances: {}, // Manual distance input per axis
                    environment: getDefaultEnvironment(),
                    executions: [],
                    requirementTemplateId: defaultTemplateId
                };
                const initialExecution = createNewExecution(testCase, defaultTemplateConfig, defaultTemplateId);
                testCase.executions.push(initialExecution);
                return testCase;
            };

            const openImportWizardForCsv = (fileName, parsedResult) => {
                if (!parsedResult || parsedResult.timestamps.length === 0) return;

                const baseName = fileName.replace(/\.csv$/i, '');
                const defaultTarget = testCases.length === 0
                    ? 'new'
                    : (activeTestCase || (testCases[0]?.id ?? 'new'));
                const selectedTc = testCases.find(tc => tc.id === defaultTarget);

                const newCaseEnvironment = {
                    ...getDefaultEnvironment(),
                    name: parsedResult.metadata?.descriptor || '',
                    dut: parsedResult.metadata?.abNumber || '',
                    notes: parsedResult.metadata?.tagVersion
                        ? `Tag version ${parsedResult.metadata.tagVersion}`
                        : ''
                };

                const suggestedEnvironment = selectedTc
                    ? { ...getDefaultEnvironment(), ...(selectedTc.environment || {}) }
                    : newCaseEnvironment;

                const defaultHardware = {
                    ...createHardwareItem(),
                    type: 'DUT',
                    name: parsedResult.metadata?.descriptor || '',
                    serialNumber: parsedResult.metadata?.abNumber || '',
                    version: parsedResult.metadata?.tagVersion || ''
                };

                setImportDialog({
                    fileName,
                    parsed: parsedResult,
                    targetTestCaseId: defaultTarget,
                    newCaseDefaults: {
                        testCaseName: baseName,
                        environment: newCaseEnvironment,
                        hardware: [defaultHardware]
                    },
                    form: {
                        testCaseName: selectedTc ? selectedTc.name : baseName,
                        environment: suggestedEnvironment,
                        executionName: baseName,
                        executionNotes: '',
                        hardware: [defaultHardware]
                    }
                });
            };

            // Import file
            const handleFileImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const content = event.target.result;

                    if (file.name.toLowerCase().endsWith('.csv')) {
                        try {
                            const result = parseDavinciCSV(content, file.name);
                            if (result && result.timestamps.length > 0) {
                                openImportWizardForCsv(file.name, result);
                            } else {
                                alert('No timestamps were detected in this CSV.');
                            }
                        } catch (err) {
                            alert('Error importing CSV: ' + err.message);
                            console.error(err);
                        }
                    } else if (file.name.toLowerCase().endsWith('.json')) {
                        try {
                            const data = JSON.parse(content);
                            let importedTemplates = requirementTemplates;
                            if (Array.isArray(data.requirementTemplates)) {
                                importedTemplates = data.requirementTemplates.map(template =>
                                    createRequirementTemplate(template)
                                );
                                setRequirementTemplates(importedTemplates);
                            } else if (data.globalRequirements) {
                                const legacyTemplate = createRequirementTemplate({
                                    name: 'Imported Requirements',
                                    config: convertLegacyRequirementsToConfig(data.globalRequirements)
                                });
                                importedTemplates = [legacyTemplate];
                                setRequirementTemplates(importedTemplates);
                            }
                            if (data.testCases) {
                                setTestCases(hydrateTestCases(
                                    data.testCases,
                                    importedTemplates,
                                    'manual-import'
                                ));
                            }
                            if (Array.isArray(data.defects)) {
                                setDefects(data.defects.map(defect => createDefectRecord(defect)));
                            }
                            if (data.sessionDiff?.selection) {
                                setSessionDiffConfig({
                                    baseline: data.sessionDiff.selection.baseline || null,
                                    candidate: data.sessionDiff.selection.candidate || null
                                });
                            }
                            if (data.sessionDiff?.annotations) {
                                setDiffAnnotations(data.sessionDiff.annotations);
                            }
                            alert('Data imported successfully!');
                        } catch (err) {
                            alert('Error importing JSON: ' + err.message);
                        }
                    }
                };

                reader.readAsText(file);
                e.target.value = '';
            };

            // Export to JSON
            const handleExportJSON = () => {
                const data = {
                    testCases,
                    requirementTemplates,
                    defects,
                    sessionDiff: {
                        selection: sessionDiffConfig,
                        annotations: diffAnnotations
                    },
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'latency-test-data-' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
                URL.revokeObjectURL(url);
            };

            const openCompareSessionsDialog = () => {
                if (executionOptions.length < 2) {
                    alert('Import or create at least two executions before comparing sessions.');
                    return;
                }
                setCompareSessionsDialog({
                    baselineKey: sessionDiffConfig.baseline
                        ? encodeExecutionKey(sessionDiffConfig.baseline.testCaseId, sessionDiffConfig.baseline.executionId)
                        : '',
                    candidateKey: sessionDiffConfig.candidate
                        ? encodeExecutionKey(sessionDiffConfig.candidate.testCaseId, sessionDiffConfig.candidate.executionId)
                        : ''
                });
            };

            const closeCompareSessionsDialog = () => setCompareSessionsDialog(null);

            const updateCompareDialogField = (field, value) => {
                setCompareSessionsDialog(prev => prev ? ({
                    ...prev,
                    [field]: value
                }) : prev);
            };

            const applyCompareSessionsSelection = () => {
                if (!compareSessionsDialog) return;
                if (!compareSessionsDialog.baselineKey || !compareSessionsDialog.candidateKey) {
                    alert('Select both baseline and candidate sessions.');
                    return;
                }
                if (compareSessionsDialog.baselineKey === compareSessionsDialog.candidateKey) {
                    alert('Baseline and candidate must be different sessions.');
                    return;
                }
                const baselineRef = decodeExecutionKey(compareSessionsDialog.baselineKey);
                const candidateRef = decodeExecutionKey(compareSessionsDialog.candidateKey);
                if (!baselineRef || !candidateRef) {
                    setSessionDiffState({
                        status: 'error',
                        message: 'Unable to read the selected sessions. Choose them again to continue.'
                    });
                    return;
                }
                if (!executionExists(baselineRef) || !executionExists(candidateRef)) {
                    setSessionDiffState({
                        status: 'error',
                        message: 'One or more selected sessions are no longer available. Import data or pick another dataset.'
                    });
                    return;
                }
                setSessionDiffState({ status: 'loading', message: 'Calculating session deltasâ€¦' });
                setSessionDiffConfig({ baseline: baselineRef, candidate: candidateRef });
                setCompareSessionsDialog(null);
                changeView('comparison');
            };

            const handleDiffAnnotation = (axisKey) => {
                const existing = diffAnnotations[axisKey] || '';
                const next = window.prompt(`Add annotation for ${axisKey}`, existing);
                if (next === null) return;
                setDiffAnnotations(prev => {
                    const nextState = { ...prev };
                    if (!next.trim()) {
                        delete nextState[axisKey];
                    } else {
                        nextState[axisKey] = next.trim();
                    }
                    return nextState;
                });
            };

            const setCopyStatusMessage = (message) => {
                setCopyDiffStatus(message);
                if (copyStatusTimeoutRef.current) {
                    clearTimeout(copyStatusTimeoutRef.current);
                }
                copyStatusTimeoutRef.current = setTimeout(() => setCopyDiffStatus(''), 4000);
            };

            const fallbackCopyText = (text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    setCopyStatusMessage('Diff summary copied to clipboard.');
                } catch (err) {
                    alert('Unable to copy diff summary: ' + err.message);
                }
                document.body.removeChild(textarea);
            };

            const copyDiffSummaryToClipboard = () => {
                if (!sessionDiffData) return;
                const summarizeStats = (stats) => {
                    if (!stats || stats.total === 0) return null;
                    return {
                        min: stats.min,
                        avg: stats.avg,
                        max: stats.max,
                        total: stats.total
                    };
                };
                const payload = {
                    release: RELEASE_VERSION,
                    generatedAt: new Date().toISOString(),
                    baseline: {
                        id: sessionDiffData.baseline.executionId,
                        testCaseId: sessionDiffData.baseline.testCaseId,
                        label: `${sessionDiffData.baseline.testCaseName} Â· ${sessionDiffData.baseline.executionName}`,
                        fps: sessionDiffData.baseline.fps,
                        source: describeDatasetSource(sessionDiffData.baseline.datasetSource),
                        hardware: sessionDiffData.baseline.hardwareSummary
                    },
                    candidate: {
                        id: sessionDiffData.candidate.executionId,
                        testCaseId: sessionDiffData.candidate.testCaseId,
                        label: `${sessionDiffData.candidate.testCaseName} Â· ${sessionDiffData.candidate.executionName}`,
                        fps: sessionDiffData.candidate.fps,
                        source: describeDatasetSource(sessionDiffData.candidate.datasetSource),
                        hardware: sessionDiffData.candidate.hardwareSummary
                    },
                    axes: sessionDiffData.axes.map(row => ({
                        axisKey: row.axisKey,
                        baseline: summarizeStats(row.baselineStats),
                        candidate: summarizeStats(row.candidateStats),
                        deltaMs: row.delta,
                        fpsDelta: row.fpsDelta,
                        hardwareDifference: row.hardwareDiff,
                        annotation: diffAnnotations[row.axisKey] || ''
                    }))
                };
                const text = JSON.stringify(payload, null, 2);
                if (navigator?.clipboard?.writeText) {
                    navigator.clipboard.writeText(text)
                        .then(() => setCopyStatusMessage('Diff summary copied to clipboard.'))
                        .catch(() => fallbackCopyText(text));
                } else {
                    fallbackCopyText(text);
                }
            };

            const updateImportTarget = (value) => {
                setImportDialog(prev => {
                    if (!prev) return prev;
                    let nextForm = { ...prev.form };
                    if (value === 'new') {
                        nextForm.testCaseName = prev.newCaseDefaults?.testCaseName || nextForm.testCaseName;
                        nextForm.environment = {
                            ...getDefaultEnvironment(),
                            ...(prev.newCaseDefaults?.environment || {})
                        };
                    } else {
                        const tc = testCases.find(item => item.id === value);
                        if (tc) {
                            nextForm.testCaseName = tc.name;
                            nextForm.environment = {
                                ...getDefaultEnvironment(),
                                ...(tc.environment || {})
                            };
                        }
                    }

                    return { ...prev, targetTestCaseId: value, form: nextForm };
                });
            };

            const updateImportFormField = (field, value) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        [field]: value
                    }
                }) : prev);
            };

            const updateImportEnvironmentField = (field, value) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        environment: {
                            ...prev.form.environment,
                            [field]: value
                        }
                    }
                }) : prev);
            };

            const updateImportHardwareField = (hardwareId, field, value) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: prev.form.hardware.map(hw =>
                            hw.id === hardwareId ? { ...hw, [field]: value } : hw
                        )
                    }
                }) : prev);
            };

            const addHardwareToImport = () => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: [...prev.form.hardware, createHardwareItem()]
                    }
                }) : prev);
            };

            const removeHardwareFromImport = (hardwareId) => {
                setImportDialog(prev => prev ? ({
                    ...prev,
                    form: {
                        ...prev.form,
                        hardware: prev.form.hardware.filter(hw => hw.id !== hardwareId)
                    }
                }) : prev);
            };

            const addDefect = () => {
                setDefects(prev => [...prev, createDefectRecord()]);
            };

            const updateDefectField = (defectId, field, value) => {
                setDefects(prev => prev.map(defect =>
                    defect.id === defectId
                        ? { ...defect, [field]: value, lastUpdated: new Date().toISOString() }
                        : defect
                ));
            };

            const deleteDefect = (defectId) => {
                setDefects(prev => prev.filter(defect => defect.id !== defectId));
            };

            const exportDefectsDocument = () => {
                const payload = {
                    release: RELEASE_VERSION,
                    lastUpdated: new Date().toISOString(),
                    defects
                };
                const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = DEFECT_EXPORT_FILENAME;
                a.click();
                URL.revokeObjectURL(url);
            };

            const closeImportDialog = () => setImportDialog(null);

            const applyRangesToDistances = (baseDistances = {}, rangesDetected = {}) => {
                const updated = { ...baseDistances };
                Object.entries(rangesDetected).forEach(([axisKey, distance]) => {
                    if (distance === null || distance === undefined) return;
                    const axis = axisKey?.[0];
                    if (!axis) return;
                    if (!updated[axis] || distance > updated[axis]) {
                        updated[axis] = distance;
                    }
                });
                return updated;
            };

            const finalizeImportDialog = () => {
                if (!importDialog) return;

                const { parsed, form, targetTestCaseId } = importDialog;
                let updatedTestCases = [...testCases];
                let targetTestCase = null;

                if (targetTestCaseId === 'new') {
                    targetTestCase = createNewTestCase();
                    targetTestCase.executions = [];
                    targetTestCase.name = form.testCaseName || targetTestCase.name;
                    targetTestCase.environment = { ...getDefaultEnvironment(), ...(form.environment || {}) };
                    targetTestCase.metadata = parsed.metadata || {};
                    updatedTestCases.push(targetTestCase);
                } else {
                    updatedTestCases = testCases.map(tc => {
                        if (tc.id === targetTestCaseId) {
                            const next = {
                                ...tc,
                                name: form.testCaseName || tc.name,
                                environment: { ...getDefaultEnvironment(), ...(form.environment || {}) },
                                metadata: { ...tc.metadata, ...(parsed.metadata || {}) }
                            };
                            targetTestCase = next;
                            return next;
                        }
                        return tc;
                    });
                }

                if (!targetTestCase) {
                    alert('Unable to locate target test case for import.');
                    return;
                }

                const templateId = targetTestCase.requirementTemplateId;
                const templateConfig = ensureTemplateConfig(templateId);
                const execution = createNewExecution(targetTestCase, templateConfig, templateId);
                execution.name = form.executionName || importDialog.fileName;
                execution.timestamps = parsed.timestamps;
                execution.fps = parsed.fps;
                execution.fpsSource = parsed.fpsSource || 'default';
                execution.datasetSource = 'automation-report';
                execution.notes = form.executionNotes;
                const sanitizedHardware = (form.hardware || [])
                    .map(hw => ({ ...hw, id: hw.id || (Date.now().toString() + Math.random()) }))
                    .filter(hw => (hw.type || hw.name || hw.serialNumber || hw.version || hw.revision || hw.notes));
                execution.hardware = sanitizedHardware;

                targetTestCase.executions = [...(targetTestCase.executions || []), execution];
                targetTestCase.distances = applyRangesToDistances(targetTestCase.distances || {}, parsed.rangesDetected || {});
                targetTestCase.metadata = { ...targetTestCase.metadata, ...(parsed.metadata || {}) };

                setTestCases(updatedTestCases);
                setActiveTestCase(targetTestCase.id);
                setActiveExecution(execution.id);

                alert('CSV imported successfully!\n' +
                    'FPS: ' + parsed.fps + '\n' +
                    'Timestamps: ' + parsed.timestamps.length + '\n' +
                    'Axes: ' + parsed.axesFound.join(', '));

                setImportDialog(null);
            };

            const getDistanceDetailsForAxisKey = (testCase, axisKey) => {
                if (!testCase) return null;
                const axis = axisKey?.[0];
                if (!axis) return null;
                const distances = testCase?.distances || {};

                if (hasDistanceValue(distances[axisKey])) {
                    return { value: distances[axisKey], source: 'manual', scope: axisKey };
                }

                if (hasDistanceValue(distances[axis])) {
                    return { value: distances[axis], source: 'manual', scope: axis };
                }

                const template = getRequirementTemplateById(testCase.requirementTemplateId);
                const templateValue = template?.config?.mustNotRespondRanges?.[axis];
                if (hasDistanceValue(templateValue)) {
                    return { value: templateValue, source: 'template', templateName: template?.name || '' };
                }

                return null;
            };

            const getDistanceForAxisKey = (testCase, axisKey) => {
                const details = getDistanceDetailsForAxisKey(testCase, axisKey);
                return details ? details.value : null;
            };

            const updateTestCaseEnvironmentField = (field, value) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            environment: {
                                ...getDefaultEnvironment(),
                                ...(tc.environment || {}),
                                [field]: value
                            }
                        };
                    }
                    return tc;
                }));
            };

            const updateExecutionField = (executionId, field, value) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id !== activeTestCase) {
                        return tc;
                    }

                    return {
                        ...tc,
                        executions: tc.executions.map(ex => {
                            if (ex.id !== executionId) {
                                return ex;
                            }

                            if (field === 'fps') {
                                const nextTimestamps = recalculateLatenciesForFps(ex.timestamps, value);
                                const parsedFps = parseFloat(value);
                                const fpsSource = parsedFps && isFinite(parsedFps) ? 'manual' : 'unknown';
                                return {
                                    ...ex,
                                    fps: value,
                                    fpsSource,
                                    timestamps: nextTimestamps
                                };
                            }

                            return { ...ex, [field]: value };
                        })
                    };
                }));
            };

            const addHardwareToExecution = () => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex =>
                                ex.id === activeExecution
                                    ? { ...ex, hardware: [...(ex.hardware || []), createHardwareItem()] }
                                    : ex
                            )
                        };
                    }
                    return tc;
                }));
            };

            const updateExecutionHardwareField = (hardwareId, field, value) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        hardware: (ex.hardware || []).map(hw =>
                                            hw.id === hardwareId ? { ...hw, [field]: value } : hw
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                }));
            };

            const removeExecutionHardware = (hardwareId) => {
                setTestCases(testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex =>
                                ex.id === activeExecution
                                    ? { ...ex, hardware: (ex.hardware || []).filter(hw => hw.id !== hardwareId) }
                                    : ex
                            )
                        };
                    }
                    return tc;
                }));
            };

            const deleteExecution = (executionId, targetTestCaseId = activeTestCase) => {
                const tc = testCases.find(item => item.id === targetTestCaseId);
                if (!tc) return;
                if (tc.executions.length === 1) {
                    alert('A test case must have at least one execution. Add another before deleting this one.');
                    return;
                }
                if (!confirm('Delete this execution? This cannot be undone.')) return;

                const updatedExecutions = tc.executions.filter(ex => ex.id !== executionId);
                const updatedTestCases = testCases.map(item =>
                    item.id === tc.id ? { ...item, executions: updatedExecutions } : item
                );
                setTestCases(updatedTestCases);

                if (targetTestCaseId === activeTestCase) {
                    setActiveExecution(updatedExecutions[0]?.id || null);
                }
            };

            // Toggle marker inclusion
            const toggleMarkerInclusion = (timestampId) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts => {
                                            if (ts.id === timestampId) {
                                                return { ...ts, excludeFromStats: !ts.excludeFromStats };
                                            }
                                            return ts;
                                        })
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            // Update axis/direction assignments
            const updateTimestampAxisDirection = (timestampId, newAxis, newDirection) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts =>
                                            ts.id === timestampId
                                                ? { ...ts, axis: newAxis, direction: newDirection }
                                                : ts
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const updateTimestampNote = (timestampId, newNote) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts =>
                                            ts.id === timestampId ? { ...ts, note: newNote } : ts
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const toggleTimestampMark = (timestampId) => {
                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.map(ts =>
                                            ts.id === timestampId ? { ...ts, isMarked: !ts.isMarked } : ts
                                        )
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const handleEditTimestampNote = (timestampId, currentNote = '') => {
                const note = prompt('Add a note for this latency measurement:', currentNote || '');
                if (note === null) return;
                updateTimestampNote(timestampId, note);
            };

            // Delete timestamp
            const handleDeleteTimestamp = (timestampId) => {
                if (!confirm('Delete this entry?')) return;

                const updated = testCases.map(tc => {
                    if (tc.id === activeTestCase) {
                        return {
                            ...tc,
                            executions: tc.executions.map(ex => {
                                if (ex.id === activeExecution) {
                                    return {
                                        ...ex,
                                        timestamps: ex.timestamps.filter(ts => ts.id !== timestampId)
                                    };
                                }
                                return ex;
                            })
                        };
                    }
                    return tc;
                });
                setTestCases(updated);
            };

            const addToComparison = (testCaseId, executionId, axisKeys = []) => {
                const targetTestCase = testCases.find(tc => tc.id === testCaseId);
                const targetExecution = targetTestCase?.executions.find(ex => ex.id === executionId);
                if (!targetTestCase || !targetExecution) return;

                const hasComparableSamples = targetExecution.timestamps.some(ts =>
                    !ts.isError && ts.latencyMs != null && !ts.excludeFromStats
                );

                if (!hasComparableSamples) {
                    alert('No comparable measurements found for this execution.');
                    return;
                }

                const comparableAxisKeys = getComparableAxisOptions(targetExecution).map(option => option.key);
                const normalizedAxisKeys = Array.isArray(axisKeys)
                    ? axisKeys.filter(axisKey => comparableAxisKeys.includes(axisKey))
                    : [];
                const entryKey = `${testCaseId}-${executionId}`;

                setComparisonExecutions(prev => {
                    const existing = prev.find(entry => entry.key === entryKey);
                    if (existing) {
                        const currentAxisSet = new Set(existing.axisKeys || []);
                        const newlyAdded = [];
                        normalizedAxisKeys.forEach(axisKey => {
                            if (!currentAxisSet.has(axisKey)) {
                                currentAxisSet.add(axisKey);
                                newlyAdded.push(axisKey);
                            }
                        });
                        if (newlyAdded.length > 0) {
                            newlyAdded.forEach(axisKey =>
                                trackAnalyticsEvent('axis_compare_added', { testCaseId, executionId, axisKey })
                            );
                        }
                        return prev.map(entry =>
                            entry.key === entryKey
                                ? { ...entry, axisKeys: Array.from(currentAxisSet) }
                                : entry
                        );
                    }

                    normalizedAxisKeys.forEach(axisKey =>
                        trackAnalyticsEvent('axis_compare_added', { testCaseId, executionId, axisKey })
                    );
                    return [...prev, { key: entryKey, testCaseId, executionId, axisKeys: normalizedAxisKeys }];
                });

                const axisSummary = normalizedAxisKeys.length > 0
                    ? `${normalizedAxisKeys.length} axis${normalizedAxisKeys.length === 1 ? '' : 'es'}`
                    : 'execution card';
                setComparisonQueueStatus(`Queued ${axisSummary} from ${targetExecution.name}`);
                if (comparisonStatusTimeoutRef.current) {
                    clearTimeout(comparisonStatusTimeoutRef.current);
                }
                comparisonStatusTimeoutRef.current = setTimeout(() => setComparisonQueueStatus(''), 4000);
            };

            const openAxisSelectionPanel = (testCaseId, executionId, initialAxisKey = null) => {
                const targetTestCase = testCases.find(tc => tc.id === testCaseId);
                const targetExecution = targetTestCase?.executions.find(ex => ex.id === executionId);
                if (!targetTestCase || !targetExecution) return;

                const axisOptions = getComparableAxisOptions(targetExecution);
                const existingEntry = comparisonExecutions.find(entry => entry.key === `${testCaseId}-${executionId}`);
                let selectedAxisKeys = [...(existingEntry?.axisKeys || [])];
                if (initialAxisKey && axisOptions.some(option => option.key === initialAxisKey) && !selectedAxisKeys.includes(initialAxisKey)) {
                    selectedAxisKeys = [...selectedAxisKeys, initialAxisKey];
                }
                setAxisSelectionPanel({
                    testCaseId,
                    executionId,
                    axisOptions,
                    selectedAxisKeys,
                    testCaseName: targetTestCase.name,
                    executionName: targetExecution.name
                });
            };

            const closeAxisSelectionPanel = () => setAxisSelectionPanel(null);

            const toggleAxisSelection = (axisKey) => {
                setAxisSelectionPanel(prev => {
                    if (!prev) return prev;
                    const isSelected = prev.selectedAxisKeys.includes(axisKey);
                    const nextSelection = isSelected
                        ? prev.selectedAxisKeys.filter(key => key !== axisKey)
                        : [...prev.selectedAxisKeys, axisKey];
                    return { ...prev, selectedAxisKeys: nextSelection };
                });
            };

            const confirmAxisSelection = () => {
                if (!axisSelectionPanel) return;
                addToComparison(axisSelectionPanel.testCaseId, axisSelectionPanel.executionId, axisSelectionPanel.selectedAxisKeys);
                closeAxisSelectionPanel();
            };

            const handleComparisonAxisToggle = (entryKey, axisKey, isEnabled) => {
                setComparisonExecutions(prev => prev.map(entry => {
                    if (entry.key !== entryKey) return entry;
                    const axisSet = new Set(entry.axisKeys || []);
                    if (isEnabled) {
                        if (axisSet.has(axisKey)) return entry;
                        axisSet.add(axisKey);
                        trackAnalyticsEvent('axis_compare_added', { testCaseId: entry.testCaseId, executionId: entry.executionId, axisKey });
                    } else {
                        if (!axisSet.has(axisKey)) return entry;
                        axisSet.delete(axisKey);
                        trackAnalyticsEvent('axis_compare_removed', { testCaseId: entry.testCaseId, executionId: entry.executionId, axisKey });
                    }
                    return { ...entry, axisKeys: Array.from(axisSet) };
                }));
            };

            const openComparisonInNewTab = () => {
                if (typeof window === 'undefined') return;
                const base = window.location.href.split('#')[0];
                window.open(`${base}#comparison`, '_blank');
            };

            const removeFromComparison = (entryKey) => {
                setComparisonExecutions(prev => {
                    const entry = prev.find(item => item.key === entryKey);
                    if (entry) {
                        (entry.axisKeys || []).forEach(axisKey =>
                            trackAnalyticsEvent('axis_compare_removed', { testCaseId: entry.testCaseId, executionId: entry.executionId, axisKey })
                        );
                    }
                    return prev.filter(item => item.key !== entryKey);
                });
            };

            // Update test case name
            const updateTestCaseName = (testCaseId, newName) => {
                const updated = testCases.map(tc =>
                    tc.id === testCaseId ? { ...tc, name: newName } : tc
                );
                setTestCases(updated);
            };

            // Delete test case
            const deleteTestCase = (testCaseId) => {
                if (!confirm('Delete this test case? This cannot be undone.')) return;

                const updated = testCases.filter(tc => tc.id !== testCaseId);
                setTestCases(updated);

                if (activeTestCase === testCaseId) {
                    setActiveTestCase(updated.length > 0 ? updated[0].id : null);
                    setActiveExecution(updated.length > 0 && updated[0].executions.length > 0 ? updated[0].executions[0].id : null);
                }
            };

            

            const updateExecutionRequirements = (field, value) => {
                if (!activeTestCase || !activeExecution) return;

                const updated = testCases.map(tc => {
                    if (tc.id !== activeTestCase) return tc;

                    return {
                        ...tc,
                        executions: tc.executions.map(ex => {
                            if (ex.id !== activeExecution) return ex;

                            const nextRequirements = applyRequirementConfigChange(ex.requirements, field, value);

                            return {
                                ...ex,
                                requirementTemplateId: null,
                                requirements: nextRequirements
                            };
                        })
                    };
                });

                setTestCases(updated);
            };

            // Get current test case and execution
            const currentTestCase = testCases.find(tc => tc.id === activeTestCase);
            const currentExecution = currentTestCase?.executions.find(ex => ex.id === activeExecution);
            const currentExecutionHasComparableSamples = currentExecution?.timestamps?.some(ts =>
                !ts.isError && ts.latencyMs != null && !ts.excludeFromStats
            );

            // Requirements Settings View
            const renderRequirementsView = () => (
                <div className="p-6 max-w-5xl space-y-6">
                    <div className="flex items-center justify-between">
                        <h2 className="text-2xl font-bold">Requirement Templates</h2>
                        <button
                            onClick={addRequirementTemplate}
                            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                        >
                            <Icon name="plus" /> Add Template
                        </button>
                    </div>

                    {hasUnsavedTemplateChanges && (
                        <div className="bg-yellow-50 border border-yellow-200 text-yellow-800 p-4 rounded">
                            <div className="font-semibold">Unsaved template edits</div>
                            <p className="text-sm mt-1">
                                Switching to another test case will auto-save these updates. Save now to dismiss this warning.
                            </p>
                            <div className="mt-3 flex flex-wrap gap-2">
                                <button
                                    onClick={clearTemplateDirtyState}
                                    className="px-3 py-1.5 text-sm bg-yellow-600 text-white rounded hover:bg-yellow-700"
                                >
                                    Save template changes
                                </button>
                            </div>
                        </div>
                    )}

                    {requirementTemplates.length === 0 ? (
                        <div className="bg-yellow-50 border border-yellow-200 text-yellow-800 p-4 rounded">
                            <p className="text-sm">No templates available. Create one using the button above.</p>
                        </div>
                    ) : (
                        requirementTemplates.map(template => (
                            <div key={template.id} className="bg-white rounded-lg shadow p-6 space-y-4">
                                <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                                    <input
                                        type="text"
                                        value={template.name}
                                        onChange={(e) => updateRequirementTemplateDetails(template.id, 'name', e.target.value)}
                                        className="text-lg font-semibold border rounded px-3 py-2 flex-1"
                                    />
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => deleteRequirementTemplate(template.id)}
                                            className="px-3 py-1.5 text-sm text-red-600 border border-red-200 rounded hover:bg-red-50"
                                            disabled={requirementTemplates.length <= 1}
                                        >
                                            <Icon name="trash-2" /> Delete
                                        </button>
                                    </div>
                                </div>
                                <textarea
                                    value={template.description}
                                    onChange={(e) => updateRequirementTemplateDetails(template.id, 'description', e.target.value)}
                                    className="w-full border rounded px-3 py-2 text-sm"
                                    rows="2"
                                    placeholder="Describe where to use this template"
                                ></textarea>
                                <div className="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        className="w-4 h-4"
                                        checked={template.config.enabled}
                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'enabled', e.target.checked)}
                                    />
                                    <span className="text-sm">Enable requirements when this template is applied</span>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Maximum Latency (ms)</label>
                                    <input
                                        type="number"
                                        value={template.config.maxLatency}
                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'maxLatency', parseFloat(e.target.value) || 100)}
                                        className="w-40 px-3 py-2 border rounded"
                                    />
                                </div>
                                <div>
                                    <h4 className="text-sm font-semibold mb-3">Range Requirements (mm)</h4>
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {AXES.map(axis => (
                                            <div key={axis} className="border rounded p-3 space-y-2">
                                                <div className="font-medium">{axis} Axis</div>
                                                <div>
                                                    <label className="block text-xs mb-1">Min Must Respond</label>
                                                    <input
                                                        type="number"
                                                        value={template.config.minRespondRanges[axis]}
                                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'minRespondRanges', {
                                                            ...template.config.minRespondRanges,
                                                            [axis]: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs mb-1">Must NOT Respond</label>
                                                    <input
                                                        type="number"
                                                        value={template.config.mustNotRespondRanges[axis]}
                                                        onChange={(e) => updateRequirementTemplateConfig(template.id, 'mustNotRespondRanges', {
                                                            ...template.config.mustNotRespondRanges,
                                                            [axis]: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        ))
                    )}

                    <div>
                        <button
                            onClick={() => changeView('execution')}
                            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                        >
                            Back to Execution View
                        </button>
                    </div>
                </div>
            );

            const renderHardwareLibraryView = () => (
                <div className="p-6 max-w-5xl space-y-6">
                    <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                        <div>
                            <h2 className="text-2xl font-bold">Hardware Bank</h2>
                            <p className="text-sm text-gray-500">Store DUTs, controllers, and fixtures so executions can reuse them without retyping metadata.</p>
                        </div>
                        <div className="flex flex-wrap gap-2">
                            <button
                                onClick={addHardwareLibraryItem}
                                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                            >
                                <Icon name="plus" /> Add Preset
                            </button>
                            <button
                                onClick={() => changeView('execution')}
                                className="px-4 py-2 border rounded hover:bg-gray-50"
                            >
                                Back to Runs
                            </button>
                        </div>
                    </div>

                    {hardwareLibrary.length === 0 ? (
                        <div className="bg-yellow-50 border border-yellow-200 text-yellow-800 p-4 rounded">
                            <p className="text-sm">No hardware presets yet. Use &ldquo;Add Preset&rdquo; to capture your commonly used equipment.</p>
                        </div>
                    ) : (
                        hardwareLibrary.map(hw => (
                            <div key={hw.id} className="bg-white rounded-lg shadow p-6 space-y-4">
                                <div className="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
                                    <div>
                                        <div className="text-lg font-semibold">{describeHardwarePreset(hw)}</div>
                                        <p className="text-xs text-gray-500">Updating any field instantly refreshes the preset.</p>
                                    </div>
                                    <div className="flex flex-wrap gap-2 text-sm">
                                        <button
                                            onClick={() => addHardwarePresetToExecution(hw.id)}
                                            disabled={!activeTestCase || !activeExecution}
                                            className={`px-3 py-1.5 rounded border ${(!activeTestCase || !activeExecution) ? 'text-gray-400 border-gray-200 cursor-not-allowed' : 'text-green-700 border-green-200 hover:bg-green-50'}`}
                                        >
                                            <Icon name="hard-drive" /> Attach to Active Execution
                                        </button>
                                        <button
                                            onClick={() => deleteHardwareLibraryItem(hw.id)}
                                            className="px-3 py-1.5 rounded border text-red-600 border-red-200 hover:bg-red-50"
                                            disabled={hardwareLibrary.length === 1}
                                        >
                                            <Icon name="trash-2" /> Remove
                                        </button>
                                    </div>
                                </div>
                                <div className="grid md:grid-cols-3 gap-3">
                                    <div>
                                        <label className="text-sm font-medium">Type</label>
                                        <input
                                            type="text"
                                            value={hw.type}
                                            onChange={(e) => updateHardwareLibraryField(hw.id, 'type', e.target.value)}
                                            className="w-full border rounded px-2 py-1"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-sm font-medium">Name</label>
                                        <input
                                            type="text"
                                            value={hw.name}
                                            onChange={(e) => updateHardwareLibraryField(hw.id, 'name', e.target.value)}
                                            className="w-full border rounded px-2 py-1"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-sm font-medium">Serial</label>
                                        <input
                                            type="text"
                                            value={hw.serialNumber}
                                            onChange={(e) => updateHardwareLibraryField(hw.id, 'serialNumber', e.target.value)}
                                            className="w-full border rounded px-2 py-1"
                                        />
                                    </div>
                                </div>
                                <div className="grid md:grid-cols-3 gap-3">
                                    <div>
                                        <label className="text-sm font-medium">Version</label>
                                        <input
                                            type="text"
                                            value={hw.version}
                                            onChange={(e) => updateHardwareLibraryField(hw.id, 'version', e.target.value)}
                                            className="w-full border rounded px-2 py-1"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-sm font-medium">Revision</label>
                                        <input
                                            type="text"
                                            value={hw.revision}
                                            onChange={(e) => updateHardwareLibraryField(hw.id, 'revision', e.target.value)}
                                            className="w-full border rounded px-2 py-1"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-sm font-medium">Notes</label>
                                        <input
                                            type="text"
                                            value={hw.notes}
                                            onChange={(e) => updateHardwareLibraryField(hw.id, 'notes', e.target.value)}
                                            className="w-full border rounded px-2 py-1"
                                        />
                                    </div>
                                </div>
                            </div>
                        ))
                    )}
                </div>
            );

            // Test Report View
            const renderReportView = () => {
                const selectedTests = testCases.filter(tc =>
                    selectedForReport.includes(tc.id)
                );

                return (
                    <div className="p-6">
                        <div className="no-print mb-6 flex justify-between items-center">
                            <h2 className="text-2xl font-bold">Test Report</h2>
                            <div className="space-x-2">
                                <button
                                    onClick={() => window.print()}
                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                >
                                    <Icon name="download" /> Print/Export PDF
                                </button>
                                <button
                                    onClick={() => changeView('execution')}
                                    className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
                                >
                                    Back
                                </button>
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow p-6">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold mb-2">Hardware Latency Test Report</h1>
                                <p className="text-gray-600">Generated: {new Date().toLocaleString()}</p>
                            </div>

                            {selectedTests.length === 0 ? (
                                <div className="text-center py-12 text-gray-500">
                                    <p>No test cases selected for report.</p>
                                    <p className="text-sm mt-2">Select test cases in the execution view to include them in the report.</p>
                                </div>
                            ) : (
                                selectedTests.map(tc => {
                                    const allTimestamps = tc.executions.flatMap(ex => ex.timestamps);
                                    const overallStats = getStatistics(allTimestamps);
                                    const axisList = [...new Set(allTimestamps
                                        .filter(ts => ts.axis && ts.direction)
                                        .map(ts => ts.axis + ts.direction)
                                    )];
                                    const axisGroups = groupByAxis(allTimestamps);
                                    const reportRequirements = getRequirementConfigForTestCase(tc);
                                    const reportTemplate = tc.requirementTemplateId
                                        ? getRequirementTemplateById(tc.requirementTemplateId)
                                        : null;
                                    const requirementTemplateName = reportTemplate?.name || 'Custom requirements';

                                    return (
                                        <div key={tc.id} className="mb-12 page-break-after">
                                            <h2 className="text-2xl font-bold mb-4 border-b pb-2">{tc.name}</h2>

                                            {/* Test Information */}
                                            <div className="mb-6">
                                                <h3 className="text-lg font-semibold mb-2">Test Information</h3>
                                                <div className="grid grid-cols-2 gap-4 text-sm">
                                                    <div>
                                                        <span className="font-medium">AB Number:</span> {tc.metadata.abNumber || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Tag Version:</span> {tc.metadata.tagVersion || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Total Executions:</span> {tc.executions.length}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Total Measurements:</span> {allTimestamps.filter(ts => !ts.isError).length}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Environment:</span> {tc.environment?.name || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Location:</span> {tc.environment?.location || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Owner:</span> {tc.environment?.owner || 'N/A'}
                                                    </div>
                                                    <div>
                                                        <span className="font-medium">Primary DUT:</span> {tc.environment?.dut || 'N/A'}
                                                    </div>
                                                    <div className="col-span-2">
                                                        <span className="font-medium">Requirement Template:</span> {requirementTemplateName}
                                                    </div>
                                                </div>
                                            </div>

                                            {reportRequirements && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Requirement Template</h3>
                                                    <div className="bg-gray-50 border rounded-lg p-4 text-sm space-y-3">
                                                        <div className="flex flex-wrap items-center justify-between gap-2">
                                                            <span className="font-medium">{requirementTemplateName}</span>
                                                            <span className={reportRequirements.enabled ? 'text-green-700 font-semibold' : 'text-gray-500 font-semibold'}>
                                                                {reportRequirements.enabled ? 'Enabled' : 'Disabled'}
                                                            </span>
                                                        </div>
                                                        {reportTemplate?.description && (
                                                            <p className="text-gray-600">{reportTemplate.description}</p>
                                                        )}
                                                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                                                            <div>
                                                                <p className="text-xs uppercase text-gray-500 tracking-wide">Max Latency</p>
                                                                <p className="font-mono font-bold">{reportRequirements.maxLatency} ms</p>
                                                            </div>
                                                            {AXES.map(axis => (
                                                                <div key={`${tc.id}-${axis}`}>
                                                                    <p className="text-xs uppercase text-gray-500 tracking-wide">{axis} Axis</p>
                                                                    <p className="font-semibold">Min Respond: {reportRequirements.minRespondRanges[axis]} mm</p>
                                                                    <p className="text-gray-600">Must NOT respond beyond {reportRequirements.mustNotRespondRanges[axis]} mm</p>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Tested Distances */}
                                            {tc.distances && Object.keys(tc.distances).length > 0 && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Tested Distances</h3>
                                                    <div className="flex flex-wrap gap-2">
                                                        {Object.entries(tc.distances)
                                                            .filter(([, distance]) => distance || distance === 0)
                                                            .map(([axis, distance]) => (
                                                                <span key={axis} className="px-3 py-1 bg-blue-100 rounded">
                                                                    {axis}: {distance}mm
                                                                </span>
                                                            ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* Overall Statistics */}
                                            <div className="mb-6">
                                                <h3 className="text-lg font-semibold mb-2">Overall Statistics</h3>
                                                <div className="grid grid-cols-4 gap-4 text-center">
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-green-600">
                                                            {formatMsToTime(overallStats.min)}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Minimum</div>
                                                    </div>
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-blue-600">
                                                            {formatMsToTime(overallStats.avg)}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Average</div>
                                                    </div>
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-red-600">
                                                            {formatMsToTime(overallStats.max)}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Maximum</div>
                                                    </div>
                                                    <div className="border rounded p-3">
                                                        <div className="text-2xl font-bold text-gray-600">
                                                            {overallStats.total}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Count</div>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Per-Axis Breakdown */}
                                            <div className="mb-6">
                                                <h3 className="text-lg font-semibold mb-2">Per-Axis Breakdown</h3>
                                                <table className="w-full text-sm">
                                                    <thead className="bg-gray-50">
                                                        <tr>
                                                            <th className="px-4 py-2 text-left">Axis</th>
                                                            <th className="px-4 py-2 text-right">Min</th>
                                                            <th className="px-4 py-2 text-right">Avg</th>
                                                            <th className="px-4 py-2 text-right">Max</th>
                                                            <th className="px-4 py-2 text-right">Count</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {axisList.map(axisKey => {
                                                            const axis = axisKey[0];
                                                            const direction = axisKey[1];
                                                            const stats = getAxisStatistics(allTimestamps, axis, direction, reportRequirements);

                                                            return (
                                                                <tr key={axisKey} className="border-t">
                                                                    <td className="px-4 py-2 font-medium">{axisKey}</td>
                                                                    <td className="px-4 py-2 text-right">{formatMsToTime(stats.min)}</td>
                                                                    <td className="px-4 py-2 text-right">{formatMsToTime(stats.avg)}</td>
                                                                    <td className="px-4 py-2 text-right">{formatMsToTime(stats.max)}</td>
                                                                    <td className="px-4 py-2 text-right">{stats.total}</td>
                                                                </tr>
                                                            );
                                                        })}
                                                    </tbody>
                                                </table>
                                            </div>

                                            {/* Requirements Check */}
                                            {reportRequirements?.enabled && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Requirements Check</h3>
                                                    <div className="text-sm">
                                                        <p><span className="font-medium">Maximum Latency:</span> {reportRequirements.maxLatency}ms</p>
                                                        <p className="mt-2">
                                                            <span className={overallStats.max <= reportRequirements.maxLatency ? 'text-green-600 font-bold' : 'text-red-600 font-bold'}>
                                                                {overallStats.max <= reportRequirements.maxLatency ? 'âœ… PASS' : 'âŒ FAIL'}
                                                            </span>
                                                        </p>
                                                    </div>
                                                </div>
                                            )}

                                            {Object.keys(axisGroups).length > 0 && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-4">Axis Execution Details</h3>
                                                    <div className="space-y-6">
                                                        {Object.entries(axisGroups).map(([axisKey, axisTimestamps]) => {
                                                            const isUngrouped = axisKey === UNGROUPED_BUCKET;
                                                            const axis = isUngrouped ? null : axisKey[0];
                                                            const direction = isUngrouped ? null : axisKey[1];
                                                            const axisStats = !isUngrouped
                                                                ? getAxisStatistics(allTimestamps, axis, direction, reportRequirements)
                                                                : getStatistics(axisTimestamps, reportRequirements);
                                                            const axisDistanceDetails = !isUngrouped ? getDistanceDetailsForAxisKey(tc, axisKey) : null;
                                                            const axisDistance = axisDistanceDetails?.value ?? null;
                                                            const requirementRange = (!isUngrouped && reportRequirements)
                                                                ? {
                                                                    minRespond: reportRequirements.minRespondRanges?.[axis],
                                                                    mustNotRespond: reportRequirements.mustNotRespondRanges?.[axis]
                                                                }
                                                                : null;
                                                            const axisErrorCount = allTimestamps.filter(ts => {
                                                                if (isUngrouped) {
                                                                    return (!ts.axis || !ts.direction) && ts.isError;
                                                                }
                                                                return ts.axis === axis && ts.direction === direction && ts.isError;
                                                            }).length;

                                                            const requirementsEnabled = reportRequirements?.enabled && !isUngrouped;
                                                            let verdictLabel = 'Not evaluated';
                                                            let verdictClass = 'text-gray-500';
                                                            if (requirementsEnabled) {
                                                                if (axisStats.total === 0) {
                                                                    verdictLabel = 'No data';
                                                                } else if (axisStats.failed > 0) {
                                                                    verdictLabel = 'âŒ FAIL';
                                                                    verdictClass = 'text-red-600 font-semibold';
                                                                } else {
                                                                    verdictLabel = 'âœ… PASS';
                                                                    verdictClass = 'text-green-600 font-semibold';
                                                                }
                                                            }

                                                            return (
                                                                <div key={axisKey} className="border rounded-lg p-4">
                                                                    <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-3 border-b pb-3 mb-3">
                                                                        <div>
                                                                            <div className="flex items-center gap-3 flex-wrap">
                                                                                <h4 className="text-xl font-semibold">
                                                                                    {isUngrouped ? 'Ungrouped Markers' : `Axis ${axisKey}`}
                                                                                </h4>
                                                                                {requirementsEnabled && (
                                                                                    <span className={verdictClass}>{verdictLabel}</span>
                                                                                )}
                                                                                {axisErrorCount > 0 && (
                                                                                    <span className="text-sm font-medium text-red-600">{axisErrorCount} error{axisErrorCount !== 1 ? 's' : ''}</span>
                                                                                )}
                                                                            </div>
                                                                            <div className="text-sm text-gray-600 flex flex-wrap gap-4 mt-2">
                                                                                {!isUngrouped && (
                                                                                    <>
                                                                                        <span className="flex flex-wrap items-center gap-2">
                                                                                            <span>Distance: {axisDistance != null ? `${axisDistance}mm` : 'N/A'}</span>
                                                                                            {axisDistanceDetails?.source === 'manual' && (
                                                                                                <span className="inline-flex items-center px-2 py-0.5 text-xs font-semibold rounded-full bg-emerald-100 text-emerald-800">
                                                                                                    Manual override
                                                                                                </span>
                                                                                            )}
                                                                                            {axisDistanceDetails?.source === 'template' && (
                                                                                                <span className="inline-flex items-center px-2 py-0.5 text-xs font-semibold rounded-full bg-indigo-100 text-indigo-800">
                                                                                                    Template{axisDistanceDetails.templateName ? ` Â· ${axisDistanceDetails.templateName}` : ''}
                                                                                                </span>
                                                                                            )}
                                                                                        </span>
                                                                                        {reportRequirements?.maxLatency != null && (
                                                                                            <span>Max Latency â‰¤ {reportRequirements.maxLatency}ms</span>
                                                                                        )}
                                                                                        {requirementRange && (
                                                                                            <>
                                                                                                {requirementRange.minRespond != null && (
                                                                                                    <span>Min Respond â‰¥ {requirementRange.minRespond}mm</span>
                                                                                                )}
                                                                                                {requirementRange.mustNotRespond != null && (
                                                                                                    <span>Must NOT Respond &gt; {requirementRange.mustNotRespond}mm</span>
                                                                                                )}
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {isUngrouped && (
                                                                                    <span>Markers without axis/direction assignments.</span>
                                                                                )}
                                                                            </div>
                                                                        </div>
                                                                        <div className="text-sm text-gray-600">
                                                                            <div>Measurements: {axisStats.total}</div>
                                                                            {requirementsEnabled && (
                                                                                <div>Pass: {axisStats.passed} Â· Fail: {axisStats.failed}</div>
                                                                            )}
                                                                        </div>
                                                                    </div>

                                                                    <div className="overflow-x-auto">
                                                                        {axisTimestamps.length === 0 ? (
                                                                            <p className="text-sm text-gray-500">No measurements recorded for this section.</p>
                                                                        ) : (
                                                                            <table className="w-full text-xs md:text-sm">
                                                                                <thead className="bg-gray-50">
                                                                                    <tr>
                                                                                        <th className="px-3 py-2 text-left">Time (s)</th>
                                                                                        <th className="px-3 py-2 text-left">Timecode</th>
                                                                                        <th className="px-3 py-2 text-left">Label</th>
                                                                                        {isUngrouped && (
                                                                                            <>
                                                                                                <th className="px-3 py-2 text-left">Axis</th>
                                                                                                <th className="px-3 py-2 text-left">Direction</th>
                                                                                            </>
                                                                                        )}
                                                                                        <th className="px-3 py-2 text-left">Note</th>
                                                                                        <th className="px-3 py-2 text-right">Latency</th>
                                                                                        <th className="px-3 py-2 text-left">Included?</th>
                                                                                    </tr>
                                                                                </thead>
                                                                                <tbody>
                                                                                    {axisTimestamps.map(ts => (
                                                                                        <tr key={ts.id} className="border-t">
                                                                                            <td className="px-3 py-2 font-mono">{ts.time || '-'}</td>
                                                                                            <td className="px-3 py-2 font-mono text-xs">{ts.recordIn || '-'}</td>
                                                                                            <td className="px-3 py-2">{ts.label}</td>
                                                                                            {isUngrouped && (
                                                                                                <>
                                                                                                    <td className="px-3 py-2">{ts.axis || '-'}</td>
                                                                                                    <td className="px-3 py-2">{ts.direction || '-'}</td>
                                                                                                </>
                                                                                            )}
                                                                                            <td className="px-3 py-2 text-xs">{ts.note || '-'}</td>
                                                                                            <td className="px-3 py-2 text-right font-mono">{ts.latency || '-'}</td>
                                                                                            <td className="px-3 py-2">{ts.excludeFromStats ? 'No' : 'Yes'}</td>
                                                                                        </tr>
                                                                                    ))}
                                                                                </tbody>
                                                                            </table>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            )}

                                            {tc.executions.some(ex => (ex.hardware || []).length > 0) && (
                                                <div className="mb-6">
                                                    <h3 className="text-lg font-semibold mb-2">Hardware Coverage</h3>
                                                    <div className="space-y-3">
                                                        {tc.executions.map(ex => (
                                                            <div key={ex.id} className="border rounded-lg p-3">
                                                                <div className="font-medium text-sm">{ex.name}</div>
                                                                {(ex.hardware || []).length > 0 ? (
                                                                    <div className="flex flex-wrap gap-2 mt-2">
                                                                        {ex.hardware.map(hw => (
                                                                            <span key={hw.id} className="px-2 py-0.5 bg-gray-100 rounded-full text-xs text-gray-700">
                                                                                {[hw.type, hw.name].filter(Boolean).join(' â€¢ ') || 'Device'}
                                                                                {hw.serialNumber ? ` (${hw.serialNumber})` : ''}
                                                                            </span>
                                                                        ))}
                                                                    </div>
                                                                ) : (
                                                                    <p className="text-xs text-gray-500 mt-2">No hardware documented.</p>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </div>
                );
            };

            const renderDefectView = () => {
                const normalizedFilter = defectFilter.trim().toLowerCase();
                const filteredDefects = defects.filter(defect => {
                    const matchesStatus = defectStatusFilter === 'all' || defect.status === defectStatusFilter;
                    const matchesSeverity = defectSeverityFilter === 'all' || defect.severity === defectSeverityFilter;
                    if (!matchesStatus || !matchesSeverity) {
                        return false;
                    }
                    if (!normalizedFilter) return true;
                    const haystack = [
                        defect.id,
                        defect.title,
                        defect.description,
                        defect.status,
                        defect.owner,
                        defect.severity
                    ].join(' ').toLowerCase();
                    return haystack.includes(normalizedFilter);
                });
                const openDefects = defects.filter(defect => defect.status !== 'Resolved').length;
                const resolvedDefects = defects.length - openDefects;

                return (
                    <div className="p-6 space-y-6">
                        <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 flex items-start space-x-3">
                            <div className="text-3xl">âš ï¸</div>
                            <div>
                                <h2 className="text-lg font-semibold text-amber-900">Release Candidate Only</h2>
                                <p className="text-sm text-amber-800">
                                    This build is provided as Hardware Latency Tester {RELEASE_VERSION}.
                                    Please avoid using it in production until all open defects are resolved.
                                </p>
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow p-4">
                            <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between mb-4">
                                <div>
                                    <h2 className="text-2xl font-bold">{RELEASE_VERSION} Defect Register</h2>
                                    <p className="text-sm text-gray-500">
                                        Track and update issues discovered while evaluating this release candidate build.
                                    </p>
                                </div>
                                <div className="flex flex-wrap gap-2">
                                    <input
                                        type="text"
                                        value={defectFilter}
                                        onChange={(e) => setDefectFilter(e.target.value)}
                                        placeholder="Search by ID, title, owner, status"
                                        className="px-3 py-2 border rounded"
                                    />
                                    <select
                                        value={defectStatusFilter}
                                        onChange={(e) => setDefectStatusFilter(e.target.value)}
                                        className="px-3 py-2 border rounded"
                                    >
                                        <option value="all">All statuses</option>
                                        {DEFECT_STATUSES.map(status => (
                                            <option key={status} value={status}>{status}</option>
                                        ))}
                                    </select>
                                    <select
                                        value={defectSeverityFilter}
                                        onChange={(e) => setDefectSeverityFilter(e.target.value)}
                                        className="px-3 py-2 border rounded"
                                    >
                                        <option value="all">All severities</option>
                                        {DEFECT_SEVERITIES.map(severity => (
                                            <option key={severity} value={severity}>{severity}</option>
                                        ))}
                                    </select>
                                    <button
                                        onClick={addDefect}
                                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        <Icon name="plus" /> New Defect
                                    </button>
                                    <button
                                        onClick={exportDefectsDocument}
                                        className="px-4 py-2 bg-gray-100 border rounded hover:bg-gray-200"
                                        disabled={defects.length === 0}
                                    >
                                        <Icon name="download" /> Save Document
                                    </button>
                                </div>
                                <div className="flex flex-wrap items-center gap-3 text-xs text-gray-600">
                                    <span>Showing {filteredDefects.length} of {defects.length} defects</span>
                                    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-red-100 text-red-700 font-semibold">
                                        <Icon name="alert-circle" /> {openDefects} Open
                                    </span>
                                    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-green-100 text-green-700 font-semibold">
                                        <Icon name="check-circle" /> {resolvedDefects} Resolved
                                    </span>
                                </div>
                            </div>

                            {filteredDefects.length === 0 ? (
                                <p className="text-sm text-gray-500">
                                    No defects match the current filter. Add a new record or adjust the filter criteria.
                                </p>
                            ) : (
                                <div className="overflow-x-auto">
                                    <table className="min-w-full text-sm">
                                        <thead className="bg-gray-50">
                                            <tr>
                                                <th className="px-3 py-2 text-left">Title</th>
                                                <th className="px-3 py-2 text-left">Description</th>
                                                <th className="px-3 py-2 text-left">Status</th>
                                                <th className="px-3 py-2 text-left">Severity</th>
                                                <th className="px-3 py-2 text-left">Owner</th>
                                                <th className="px-3 py-2 text-left">Updated</th>
                                                <th className="px-3 py-2 text-center">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {filteredDefects.map(defect => (
                                                <tr key={defect.id} className="border-t align-top">
                                                    <td className="px-3 py-2 w-48">
                                                        <input
                                                            type="text"
                                                            value={defect.title}
                                                            onChange={(e) => updateDefectField(defect.id, 'title', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                            placeholder="e.g. CSV import fails"
                                                        />
                                                    </td>
                                                    <td className="px-3 py-2">
                                                        <textarea
                                                            value={defect.description}
                                                            onChange={(e) => updateDefectField(defect.id, 'description', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                            style={{ minHeight: '60px' }}
                                                            placeholder="Describe the failure, reproduction steps, and impact"
                                                        />
                                                    </td>
                                                    <td className="px-3 py-2 w-40">
                                                        <select
                                                            value={defect.status}
                                                            onChange={(e) => updateDefectField(defect.id, 'status', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                        >
                                                            {DEFECT_STATUSES.map(status => (
                                                                <option key={status} value={status}>{status}</option>
                                                            ))}
                                                        </select>
                                                    </td>
                                                    <td className="px-3 py-2 w-32">
                                                        <select
                                                            value={defect.severity}
                                                            onChange={(e) => updateDefectField(defect.id, 'severity', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                        >
                                                            {DEFECT_SEVERITIES.map(severity => (
                                                                <option key={severity} value={severity}>{severity}</option>
                                                            ))}
                                                        </select>
                                                    </td>
                                                    <td className="px-3 py-2 w-32">
                                                        <input
                                                            type="text"
                                                            value={defect.owner}
                                                            onChange={(e) => updateDefectField(defect.id, 'owner', e.target.value)}
                                                            className="w-full border rounded px-2 py-1"
                                                            placeholder="Assignee"
                                                        />
                                                    </td>
                                                    <td className="px-3 py-2 text-sm text-gray-500 w-40">
                                                        {new Date(defect.lastUpdated).toLocaleString()}
                                                    </td>
                                                    <td className="px-3 py-2 text-center w-20">
                                                        <button
                                                            onClick={() => deleteDefect(defect.id)}
                                                            className="text-red-600 hover:text-red-800"
                                                        >
                                                            <Icon name="trash-2" />
                                                        </button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>

                        <div className="bg-white rounded-lg shadow p-4 text-sm text-gray-600">
                            <p>
                                The canonical defect register for this release candidate lives at
                                <code className="mx-1 bg-gray-100 px-1 py-0.5 rounded">release-candidates/v3.9-rc3-defects.json</code>.
                                You can edit that file directly in a text editor or synchronize it by importing and exporting
                                from the GUI controls above.
                            </p>
                            <p className="mt-2">
                                To refresh this table from a manually edited document use the global <strong>Import</strong>
                                button and select the JSON file. Saving from this view will download a ready-to-commit
                                replacement document.
                            </p>
                        </div>
                    </div>
                );
            };

            const renderImportModal = () => {
                if (!importDialog) return null;
                const { parsed, form, targetTestCaseId } = importDialog;
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white rounded-lg shadow-xl w-full max-w-5xl max-h-[90vh] overflow-y-auto">
                            <div className="px-6 py-4 border-b flex items-center justify-between">
                                <div>
                                    <h2 className="text-xl font-semibold">CSV Import Wizard</h2>
                                    <p className="text-sm text-gray-500">Provide test case context before creating the execution.</p>
                                </div>
                                <button onClick={closeImportDialog} className="text-gray-500 hover:text-gray-700">
                                    <Icon name="x" />
                                </button>
                            </div>
                            <div className="p-6 space-y-6">
                                <div className="grid md:grid-cols-2 gap-4">
                                    <div className="bg-gray-50 rounded-lg p-4">
                                        <h3 className="font-semibold mb-2">File Insights</h3>
                                        <p className="text-sm"><span className="font-medium">File:</span> {importDialog.fileName}</p>
                                        <p className="text-sm">
                                            <span className="font-medium">Detected FPS:</span> {parsed.fps}
                                            <span className="ml-2 text-xs text-gray-500">
                                                {parsed.fpsSource === 'csv'
                                                    ? '(from CSV metadata)'
                                                    : '(defaulted â€” update if this clip used a different rate)'}
                                            </span>
                                        </p>
                                        <p className="text-sm"><span className="font-medium">Timestamps:</span> {parsed.timestamps.length}</p>
                                        <p className="text-sm"><span className="font-medium">Axes:</span> {parsed.axesFound.length > 0 ? parsed.axesFound.join(', ') : 'N/A'}</p>
                                        {parsed.metadata?.abNumber && (
                                            <p className="text-sm text-gray-600 mt-2">Suggested DUT: {parsed.metadata.abNumber}</p>
                                        )}
                                    </div>
                                    <div className="bg-gray-50 rounded-lg p-4 space-y-3">
                                        <div>
                                            <label className="text-sm font-medium">Attach to Test Case</label>
                                            <select
                                                className="w-full border rounded px-3 py-2"
                                                value={targetTestCaseId}
                                                onChange={(e) => updateImportTarget(e.target.value)}
                                            >
                                                <option value="new">â• Create new test case</option>
                                                {testCases.map(tc => (
                                                    <option key={tc.id} value={tc.id}>{tc.name}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Test Case Name</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.testCaseName}
                                                onChange={(e) => updateImportFormField('testCaseName', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Execution Name</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.executionName}
                                                onChange={(e) => updateImportFormField('executionName', e.target.value)}
                                            />
                                        </div>
                                    </div>
                                </div>

                                <div className="grid md:grid-cols-2 gap-4">
                                    <div className="space-y-3">
                                        <h3 className="font-semibold">Test Environment</h3>
                                        <div>
                                            <label className="text-sm font-medium">Environment Name</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.name}
                                                onChange={(e) => updateImportEnvironmentField('name', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Location</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.location}
                                                onChange={(e) => updateImportEnvironmentField('location', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Owner / Operator</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.owner}
                                                onChange={(e) => updateImportEnvironmentField('owner', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Primary DUT / Build</label>
                                            <input
                                                type="text"
                                                className="w-full border rounded px-3 py-2"
                                                value={form.environment.dut}
                                                onChange={(e) => updateImportEnvironmentField('dut', e.target.value)}
                                            />
                                        </div>
                                        <div>
                                            <label className="text-sm font-medium">Notes</label>
                                            <textarea
                                                className="w-full border rounded px-3 py-2"
                                                rows="3"
                                                value={form.environment.notes}
                                                onChange={(e) => updateImportEnvironmentField('notes', e.target.value)}
                                            ></textarea>
                                        </div>
                                    </div>
                                    <div className="space-y-3">
                                        <h3 className="font-semibold">Execution Notes</h3>
                                        <textarea
                                            className="w-full border rounded px-3 py-2"
                                            rows="6"
                                            value={form.executionNotes}
                                            onChange={(e) => updateImportFormField('executionNotes', e.target.value)}
                                            placeholder="Describe the scenario, stimulus, or anything unique about this run."
                                        ></textarea>
                                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                                            Suggestions are generated from the CSV metadata and filename. Adjust anything that
                                            differs for this import.
                                        </div>
                                    </div>
                                </div>

                                <div>
                                    <div className="flex flex-wrap items-center justify-between gap-2 mb-3">
                                        <h3 className="font-semibold">Test Hardware</h3>
                                        <div className="flex flex-wrap gap-2">
                                            <button
                                                onClick={() => changeView('hardware')}
                                                className="px-3 py-1.5 border rounded hover:bg-gray-50 text-sm"
                                            >
                                                <Icon name="hard-drive" /> Manage Bank
                                            </button>
                                            <button
                                                onClick={addHardwareToImport}
                                                className="px-3 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                                            >
                                                <Icon name="plus" /> Add Hardware
                                            </button>
                                        </div>
                                    </div>
                                    {hardwareLibrary.length > 0 && (
                                        <div className="flex flex-col md:flex-row gap-2 mb-3">
                                            <select
                                                className="flex-1 border rounded px-3 py-1.5 text-sm"
                                                value={importHardwareLibrarySelection}
                                                onChange={(e) => setImportHardwareLibrarySelection(e.target.value)}
                                            >
                                                <option value="">Select a hardware preset</option>
                                                {hardwareLibrary.map(hw => (
                                                    <option key={hw.id} value={hw.id}>{describeHardwarePreset(hw)}</option>
                                                ))}
                                            </select>
                                            <button
                                                onClick={() => addHardwarePresetToImport(importHardwareLibrarySelection)}
                                                disabled={!importHardwareLibrarySelection}
                                                className={`px-3 py-1.5 text-sm rounded ${importHardwareLibrarySelection ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-gray-200 text-gray-500 cursor-not-allowed'}`}
                                            >
                                                <Icon name="plus" /> Add from Bank
                                            </button>
                                        </div>
                                    )}
                                    {form.hardware.length === 0 ? (
                                        <p className="text-sm text-gray-500">No hardware linked yet.</p>
                                    ) : (
                                        <div className="space-y-3">
                                            {form.hardware.map(hw => (
                                                <div key={hw.id} className="border rounded-lg p-3 space-y-3">
                                                    <div className="grid md:grid-cols-3 gap-3">
                                                        <div>
                                                            <label className="text-sm font-medium">Hardware Type</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.type}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'type', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Name</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.name}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'name', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Serial Number</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.serialNumber}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'serialNumber', e.target.value)}
                                                            />
                                                        </div>
                                                    </div>
                                                    <div className="grid md:grid-cols-3 gap-3">
                                                        <div>
                                                            <label className="text-sm font-medium">Version</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.version}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'version', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Revision</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.revision}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'revision', e.target.value)}
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-sm font-medium">Notes</label>
                                                            <input
                                                                type="text"
                                                                className="w-full border rounded px-2 py-1"
                                                                value={hw.notes}
                                                                onChange={(e) => updateImportHardwareField(hw.id, 'notes', e.target.value)}
                                                            />
                                                        </div>
                                                    </div>
                                                    <div className="text-right">
                                                        <button
                                                            onClick={() => removeHardwareFromImport(hw.id)}
                                                            className="text-sm text-red-600 hover:text-red-800"
                                                        >
                                                            <Icon name="trash-2" /> Remove
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="px-6 py-4 border-t flex justify-end gap-3 bg-gray-50">
                                <button onClick={closeImportDialog} className="px-4 py-2 border rounded">Cancel</button>
                                <button
                                    onClick={finalizeImportDialog}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Create Execution
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderAxisSelectionPanel = () => {
                if (!axisSelectionPanel) return null;
                const { testCaseName, executionName, axisOptions, selectedAxisKeys } = axisSelectionPanel;
                const hasAxisOptions = axisOptions.length > 0;
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-end z-40">
                        <div className="w-full max-w-md bg-white h-full shadow-xl p-6 overflow-y-auto">
                            <div className="flex items-start justify-between mb-4">
                                <div>
                                    <p className="text-xs uppercase text-gray-500 tracking-wide">Execution â€º {testCaseName} â€º {executionName} â€º Compare axes</p>
                                    <h2 className="text-xl font-semibold mt-1">Select axes for comparison</h2>
                                    <p className="text-sm text-gray-600">Pick multiple axes/directions before queueing them. You will stay on this execution after confirming.</p>
                                </div>
                                <button onClick={closeAxisSelectionPanel} className="text-gray-500 hover:text-gray-700">
                                    <Icon name="x" />
                                </button>
                            </div>
                            {hasAxisOptions ? (
                                <div className="space-y-3">
                                    {axisOptions.map(option => {
                                        const checked = selectedAxisKeys.includes(option.key);
                                        return (
                                            <label key={option.key} className={`flex items-center justify-between border rounded-lg px-3 py-2 ${checked ? 'border-blue-400 bg-blue-50' : 'border-gray-200'}`}>
                                                <div>
                                                    <p className="font-semibold">Axis {option.key}</p>
                                                    <p className="text-xs text-gray-500">{option.count} measurements available</p>
                                                </div>
                                                <input
                                                    type="checkbox"
                                                    checked={checked}
                                                    onChange={() => toggleAxisSelection(option.key)}
                                                    className="h-4 w-4"
                                                />
                                            </label>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 text-sm text-amber-800">
                                    Tag at least one axis/direction in this execution before sending it to comparison.
                                </div>
                            )}
                            <div className="mt-6 space-y-2">
                                <button
                                    onClick={confirmAxisSelection}
                                    className="w-full px-4 py-2 rounded text-white bg-blue-600 hover:bg-blue-700"
                                >
                                    Add selection to comparison
                                </button>
                                <button
                                    onClick={() => { closeAxisSelectionPanel(); changeView('comparison'); }}
                                    className="w-full px-4 py-2 rounded border border-gray-200 text-gray-700 hover:bg-gray-50"
                                >
                                    Review comparison dashboard
                                </button>
                                <button
                                    onClick={() => { closeAxisSelectionPanel(); openComparisonInNewTab(); }}
                                    className="w-full px-4 py-2 rounded border border-blue-200 text-blue-700 hover:bg-blue-50"
                                >
                                    Open comparison in new tab
                                </button>
                            </div>
                            <p className="text-xs text-gray-500 mt-4">Axis selections persist between sessions. You can also toggle axes directly from the comparison cards.</p>
                        </div>
                    </div>
                );
            };

            const renderCompareSessionsModal = () => {
                if (!compareSessionsDialog) return null;
                const baselineOption = executionOptions.find(opt => opt.value === compareSessionsDialog.baselineKey);
                const candidateOption = executionOptions.find(opt => opt.value === compareSessionsDialog.candidateKey);
                const summaryCard = (option, heading) => (
                    <div className="bg-gray-50 rounded-lg p-3 text-sm">
                        <h4 className="font-semibold text-gray-700">{heading}</h4>
                        {option ? (
                            <>
                                <p className="font-medium">{option.label}</p>
                                <p className="text-xs text-gray-500">{describeDatasetSource(option.datasetSource)}</p>
                                <p className="text-xs text-gray-500">FPS: {option.fps || 'â€”'} Â· Samples: {option.timestampCount}</p>
                                <p className="text-xs text-gray-500">Hardware entries: {option.hardwareCount}</p>
                            </>
                        ) : (
                            <p className="text-xs text-gray-500">Select a session to see metadata.</p>
                        )}
                    </div>
                );
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div className="bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
                            <div className="px-6 py-4 border-b flex items-center justify-between">
                                <div>
                                    <h2 className="text-xl font-semibold">Compare Sessions</h2>
                                    <p className="text-sm text-gray-500">Choose a baseline dataset and a candidate dataset from your manual or automation imports.</p>
                                </div>
                                <button onClick={closeCompareSessionsDialog} className="text-gray-500 hover:text-gray-700">
                                    <Icon name="x" />
                                </button>
                            </div>
                            <div className="p-6 space-y-6">
                                <div className="grid md:grid-cols-2 gap-4">
                                    <div>
                                        <label className="text-sm font-medium">Baseline Dataset</label>
                                        <select
                                            className="w-full border rounded px-3 py-2 mt-1"
                                            value={compareSessionsDialog.baselineKey}
                                            onChange={(e) => updateCompareDialogField('baselineKey', e.target.value)}
                                        >
                                            <option value="">Select baseline</option>
                                            {executionOptions.map(option => (
                                                <option key={option.value} value={option.value}>{option.label} Â· {describeDatasetSource(option.datasetSource)}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-sm font-medium">Candidate Dataset</label>
                                        <select
                                            className="w-full border rounded px-3 py-2 mt-1"
                                            value={compareSessionsDialog.candidateKey}
                                            onChange={(e) => updateCompareDialogField('candidateKey', e.target.value)}
                                        >
                                            <option value="">Select candidate</option>
                                            {executionOptions.map(option => (
                                                <option key={option.value} value={option.value}>{option.label} Â· {describeDatasetSource(option.datasetSource)}</option>
                                            ))}
                                        </select>
                                    </div>
                                </div>
                                <div className="grid md:grid-cols-2 gap-4">
                                    {summaryCard(baselineOption, 'Baseline metadata')}
                                    {summaryCard(candidateOption, 'Candidate metadata')}
                                </div>
                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 text-xs text-blue-800">
                                    Baseline should represent your known-good dataset. The candidate run is compared against it for min/avg/max latency, FPS, and hardware differences.
                                </div>
                            </div>
                            <div className="px-6 py-4 border-t bg-gray-50 flex justify-end gap-3">
                                <button onClick={closeCompareSessionsDialog} className="px-4 py-2 border rounded">Cancel</button>
                                <button
                                    onClick={applyCompareSessionsSelection}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Apply Selection
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // Execution View
            const renderExecutionView = () => {
                if (!currentTestCase || !currentExecution) {
                    return (
                        <div className="flex items-center justify-center h-full">
                            <div className="text-center">
                                <p className="text-gray-500 text-lg mb-4">No test case loaded</p>
                                <button
                                    onClick={() => runWithTemplateGuard(() => {
                                        const newTC = createNewTestCase();
                                        setTestCases([...testCases, newTC]);
                                        setActiveTestCase(newTC.id);
                                        setActiveExecution(newTC.executions[0].id);
                                    })}
                                    className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                >
                                    <Icon name="plus" /> Create New Test Case
                                </button>
                            </div>
                        </div>
                    );
                }

                const timestamps = currentExecution.timestamps;
                const requirements = mergeExecutionRequirements(currentExecution.requirements);
                const overallStats = getStatistics(timestamps, requirements);
                const axisGroups = groupByAxis(timestamps);
                const ungroupedCount = timestamps.filter(ts => !ts.isError && (!ts.axis || !ts.direction)).length;
                const errorEvents = timestamps.filter(ts => ts.isError);
                const axisSummaries = AXES.map(axis => ({
                    axis,
                    stats: getStatistics(timestamps.filter(ts => ts.axis === axis), requirements)
                }));
                const fpsSourceNote = (() => {
                    const source = currentExecution.fpsSource;
                    if (source === 'csv') {
                        return 'Detected from CSV metadata.';
                    }
                    if (source === 'manual') {
                        return 'Manual override applied â€” the latencies reflect this FPS.';
                    }
                    if (source === 'default') {
                        return 'No FPS metadata detected, using the default 30 fps conversion.';
                    }
                    return 'Provide an FPS value to re-run the timecode conversions if needed.';
                })();

                // Group errors by error number
                const errorsByNumber = {};
                errorEvents.forEach(err => {
                    if (err.errorNumber) {
                        if (!errorsByNumber[err.errorNumber]) {
                            errorsByNumber[err.errorNumber] = [];
                        }
                        errorsByNumber[err.errorNumber].push(err);
                    }
                });

                return (
                    <div className="p-6">
                        {/* Test Case Header */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex items-center justify-between">
                                <div className="flex-1">
                                    <input
                                        type="text"
                                        value={currentTestCase.name}
                                        onChange={(e) => updateTestCaseName(currentTestCase.id, e.target.value)}
                                        className="text-xl font-bold border-b border-transparent hover:border-gray-300 focus:border-blue-500 outline-none px-2 py-1"
                                    />
                                </div>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={() => {
                                            setSelectedForReport(prev =>
                                                prev.includes(currentTestCase.id)
                                                    ? prev.filter(id => id !== currentTestCase.id)
                                                    : [...prev, currentTestCase.id]
                                            );
                                        }}
                                        className={`px-3 py-1 rounded ${
                                            selectedForReport.includes(currentTestCase.id)
                                                ? 'bg-green-600 text-white'
                                                : 'bg-gray-200 text-gray-700'
                                        }`}
                                    >
                                        <Icon name={selectedForReport.includes(currentTestCase.id) ? 'check' : 'eye'} />
                                        {selectedForReport.includes(currentTestCase.id) ? 'In Report' : 'Add to Report'}
                                    </button>
                                    <button
                                        onClick={() => deleteTestCase(currentTestCase.id)}
                                        className="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700"
                                    >
                                        <Icon name="trash-2" /> Delete Test Case
                                    </button>
                                </div>
                            </div>
                        </div>

                        {ungroupedCount > 0 && (
                            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                                <div className="text-sm font-semibold text-yellow-800">
                                    Import summary alert
                                </div>
                                <p className="text-xs md:text-sm text-yellow-700 mt-1">
                                    This import contains <span className="font-semibold">{ungroupedCount}</span> marker{ungroupedCount !== 1 ? 's' : ''} without axis/direction tags. Use the Ungrouped bucket below to assign an axis and direction so they appear in the correct sections.
                                </p>
                            </div>
                        )}

                        {comparisonExecutions.length > 0 && (
                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4 flex flex-wrap items-start gap-4">
                                <div className="flex-1 min-w-[240px]">
                                    <p className="text-xs uppercase font-semibold text-blue-700 tracking-wide">Comparison queue</p>
                                    <p className="text-sm text-blue-900 mt-1">
                                        Execution â€º {currentTestCase.name} â€º {currentExecution.name} â€º Compare axes
                                    </p>
                                    <p className="text-xs text-blue-800 mt-1">
                                        Stay in this execution while we hold your axis selections. Jump to the dashboard when you are ready or open it in a new tab.
                                    </p>
                                    {comparisonQueueStatus && (
                                        <p className="text-xs text-blue-900 font-semibold mt-1">{comparisonQueueStatus}</p>
                                    )}
                                </div>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => changeView('comparison')}
                                        className="px-3 py-1.5 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        View comparison
                                    </button>
                                    <button
                                        onClick={openComparisonInNewTab}
                                        className="px-3 py-1.5 text-sm border border-blue-200 rounded text-blue-700 hover:bg-blue-100"
                                    >
                                        Open in new tab
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Test Environment */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <h3 className="font-semibold mb-3">Test Environment</h3>
                            <div className="grid md:grid-cols-2 gap-3">
                                <div>
                                    <label className="block text-sm font-medium mb-1">Environment Name</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.name || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('name', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Location</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.location || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('location', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Owner / Operator</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.owner || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('owner', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">Primary DUT / Build</label>
                                    <input
                                        type="text"
                                        value={currentTestCase.environment?.dut || ''}
                                        onChange={(e) => updateTestCaseEnvironmentField('dut', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                            </div>
                            <div className="mt-3">
                                <label className="block text-sm font-medium mb-1">Notes</label>
                                <textarea
                                    value={currentTestCase.environment?.notes || ''}
                                    onChange={(e) => updateTestCaseEnvironmentField('notes', e.target.value)}
                                    className="w-full border rounded px-3 py-2"
                                    rows="3"
                                ></textarea>
                            </div>
                        </div>

                        {/* Requirements Selection */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                                <div>
                                    <h3 className="font-semibold mb-1">Pass/Fail Requirements</h3>
                                    <p className="text-xs text-gray-500">Set min/max read ranges and responsiveness latency for this execution.</p>
                                </div>
                                <div className="flex flex-wrap gap-2 items-center">
                                    <select
                                        className="px-3 py-1.5 border rounded text-sm"
                                        value={currentTestCase.requirementTemplateId || ''}
                                        onChange={(e) => {
                                            const nextTemplateId = e.target.value || null;
                                            updateTestCaseTemplateSelection(nextTemplateId);
                                            if (nextTemplateId) {
                                                applyTemplateToExecution(currentExecution.id, nextTemplateId);
                                            }
                                        }}
                                    >
                                        <option value="">No Template Selected</option>
                                        {requirementTemplates.map(template => (
                                            <option key={template.id} value={template.id}>{template.name}</option>
                                        ))}
                                    </select>
                                    <button
                                        onClick={() => applyTemplateToExecution(currentExecution.id, currentTestCase.requirementTemplateId)}
                                        className="px-3 py-1.5 text-sm border rounded text-gray-700 hover:bg-gray-50"
                                        disabled={!currentTestCase.requirementTemplateId}
                                    >
                                        Apply to Execution
                                    </button>
                                    <button
                                        onClick={() => applyTemplateToAllExecutions(currentTestCase.requirementTemplateId)}
                                        className="px-3 py-1.5 text-sm border rounded text-gray-700 hover:bg-gray-50"
                                        disabled={!currentTestCase.requirementTemplateId}
                                    >
                                        Apply to All
                                    </button>
                                    <button
                                        onClick={() => changeView('requirements')}
                                        className="px-3 py-1.5 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        Manage Templates
                                    </button>
                                </div>
                            </div>

                            <div className="flex items-center mt-4 gap-2">
                                <input
                                    type="checkbox"
                                    checked={requirements.enabled}
                                    onChange={(e) => updateExecutionRequirements('enabled', e.target.checked)}
                                    className="w-4 h-4"
                                />
                                <span className="text-sm font-medium">Enable requirements checking for this execution</span>
                            </div>

                            {requirements.enabled && (
                                <>
                                    <div className="mt-4">
                                        <label className="block text-sm mb-1">Max Latency (ms)</label>
                                        <input
                                            type="number"
                                            value={requirements.maxLatency}
                                            onChange={(e) => updateExecutionRequirements('maxLatency', parseFloat(e.target.value) || 100)}
                                            className="w-32 px-2 py-1 border rounded text-sm"
                                        />
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                                        {AXES.map(axis => (
                                            <div key={axis} className="border rounded p-3">
                                                <div className="font-medium mb-2">{axis} Axis</div>
                                                <div className="space-y-2">
                                                    <div>
                                                        <label className="block text-xs mb-1">Min Must Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.minRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('minRespondRanges', {
                                                                ...requirements.minRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs mb-1">Must NOT Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.mustNotRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('mustNotRespondRanges', {
                                                                ...requirements.mustNotRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    {sessionDiffAxisAggregate[axis] && (
                                                        <div className="text-xs text-gray-600 border-t pt-2 space-y-1">
                                                            {['plus', 'minus'].map(directionKey => {
                                                                const row = sessionDiffAxisAggregate[axis][directionKey];
                                                                if (!row) return null;
                                                                const directionLabel = directionKey === 'plus' ? '+' : '-';
                                                                return (
                                                                    <div key={directionKey} className="flex flex-wrap items-center gap-2">
                                                                        <span className="font-semibold">{axis}{directionLabel}</span>
                                                                        <span className={`inline-flex items-center px-2 py-0.5 rounded-full font-semibold ${getDeltaBadgeClasses(row.delta.avg)}`}>
                                                                            Î” Avg: {formatDeltaMs(row.delta.avg)}
                                                                        </span>
                                                                        <button
                                                                            type="button"
                                                                            onClick={() => handleDiffAnnotation(axis + directionLabel)}
                                                                            className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-blue-50 text-blue-700"
                                                                        >
                                                                            <Icon name="pin" /> {diffAnnotations[axis + directionLabel] ? 'Edit pin' : 'Pin note'}
                                                                        </button>
                                                                    </div>
                                                                );
                                                            })}
                                                            {(diffAnnotations[axis + '+'] || diffAnnotations[axis + '-']) && (
                                                                <div className="text-amber-700 italic flex items-start gap-1">
                                                                    <Icon name="pin" />
                                                                    <span>{[diffAnnotations[axis + '+'], diffAnnotations[axis + '-']].filter(Boolean).join(' / ')}</span>
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                        </div>

                        {/* Execution Details */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex items-center justify-between mb-3 flex-wrap gap-2">
                                <h3 className="font-semibold">Execution Details</h3>
                                <button
                                    onClick={() => deleteExecution(currentExecution.id)}
                                    className="px-3 py-1.5 text-sm text-red-600 border border-red-200 rounded hover:bg-red-50"
                                >
                                    <Icon name="trash-2" /> Delete Execution
                                </button>
                            </div>
                            <div className="grid md:grid-cols-2 gap-3">
                                <div>
                                    <label className="block text-sm font-medium mb-1">Execution Name</label>
                                    <input
                                        type="text"
                                        value={currentExecution.name}
                                        onChange={(e) => updateExecutionField(currentExecution.id, 'name', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1">FPS (from import)</label>
                                    <input
                                        type="text"
                                        value={currentExecution.fps || ''}
                                        onChange={(e) => updateExecutionField(currentExecution.id, 'fps', e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                        placeholder="e.g., 240"
                                    />
                                    <p className="text-xs text-gray-500 mt-1">{fpsSourceNote}</p>
                                </div>
                            </div>
                            <div className="mt-3">
                                <label className="block text-sm font-medium mb-1">Notes</label>
                                <textarea
                                    value={currentExecution.notes || ''}
                                    onChange={(e) => updateExecutionField(currentExecution.id, 'notes', e.target.value)}
                                    className="w-full border rounded px-3 py-2"
                                    rows="3"
                                    placeholder="Add any observations for this execution."
                                ></textarea>
                            </div>
                        </div>

                        {/* Execution Hardware */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <div className="flex flex-wrap items-center justify-between gap-2 mb-3">
                                <h3 className="font-semibold">Execution Hardware</h3>
                                <div className="flex flex-wrap gap-2">
                                    <button
                                        onClick={() => changeView('hardware')}
                                        className="px-3 py-1.5 text-sm border rounded hover:bg-gray-50"
                                    >
                                        <Icon name="hard-drive" /> Manage Bank
                                    </button>
                                    <button
                                        onClick={addHardwareToExecution}
                                        className="px-3 py-1.5 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
                                    >
                                        <Icon name="plus" /> Add Hardware
                                    </button>
                                </div>
                            </div>
                            {hardwareLibrary.length > 0 && (
                                <div className="flex flex-col md:flex-row gap-2 mb-3">
                                    <select
                                        className="flex-1 border rounded px-3 py-1.5 text-sm"
                                        value={executionHardwareLibrarySelection}
                                        onChange={(e) => setExecutionHardwareLibrarySelection(e.target.value)}
                                    >
                                        <option value="">Select a hardware preset</option>
                                        {hardwareLibrary.map(hw => (
                                            <option key={hw.id} value={hw.id}>{describeHardwarePreset(hw)}</option>
                                        ))}
                                    </select>
                                    <button
                                        onClick={() => addHardwarePresetToExecution(executionHardwareLibrarySelection)}
                                        disabled={!executionHardwareLibrarySelection}
                                        className={`px-3 py-1.5 text-sm rounded ${executionHardwareLibrarySelection ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-gray-200 text-gray-500 cursor-not-allowed'}`}
                                    >
                                        <Icon name="plus" /> Add from Bank
                                    </button>
                                </div>
                            )}
                            {(!currentExecution.hardware || currentExecution.hardware.length === 0) ? (
                                <p className="text-sm text-gray-500">No hardware linked. Use the button above to add devices.</p>
                            ) : (
                                <div className="space-y-3">
                                    {currentExecution.hardware.map(hw => (
                                        <div key={hw.id} className="border rounded-lg p-3 space-y-3">
                                            <div className="grid md:grid-cols-3 gap-3">
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Type</label>
                                                    <input
                                                        type="text"
                                                        value={hw.type}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'type', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Name</label>
                                                    <input
                                                        type="text"
                                                        value={hw.name}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'name', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Serial</label>
                                                    <input
                                                        type="text"
                                                        value={hw.serialNumber}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'serialNumber', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                            </div>
                                            <div className="grid md:grid-cols-3 gap-3">
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Version</label>
                                                    <input
                                                        type="text"
                                                        value={hw.version}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'version', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Revision</label>
                                                    <input
                                                        type="text"
                                                        value={hw.revision}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'revision', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium mb-1">Notes</label>
                                                    <input
                                                        type="text"
                                                        value={hw.notes}
                                                        onChange={(e) => updateExecutionHardwareField(hw.id, 'notes', e.target.value)}
                                                        className="w-full border rounded px-2 py-1"
                                                    />
                                                </div>
                                            </div>
                                            <div className="text-right">
                                                <button
                                                    onClick={() => removeExecutionHardware(hw.id)}
                                                    className="text-sm text-red-600 hover:text-red-800"
                                                >
                                                    <Icon name="trash-2" /> Remove
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        {/* Requirements Settings */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <h3 className="font-semibold mb-3">Pass/Fail Requirements</h3>
                            <div className="flex items-center mb-3">
                                <input
                                    type="checkbox"
                                    checked={requirements.enabled}
                                    onChange={(e) => updateExecutionRequirements('enabled', e.target.checked)}
                                    className="w-4 h-4 mr-2"
                                />
                                <label className="text-sm font-medium">Enable Requirements Checking</label>
                            </div>

                            {requirements.enabled && (
                                <>
                                    <div className="mb-3">
                                        <label className="block text-sm mb-1">Max Latency (ms)</label>
                                        <input
                                            type="number"
                                            value={requirements.maxLatency}
                                            onChange={(e) => updateExecutionRequirements('maxLatency', parseFloat(e.target.value) || 100)}
                                            className="w-32 px-2 py-1 border rounded text-sm"
                                        />
                                    </div>

                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {AXES.map(axis => (
                                            <div key={axis} className="border rounded p-3">
                                                <div className="font-medium mb-2">{axis} Axis</div>
                                                <div className="space-y-2">
                                                    <div>
                                                        <label className="block text-xs mb-1">Min Must Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.minRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('minRespondRanges', {
                                                                ...requirements.minRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs mb-1">Must NOT Respond (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={requirements.mustNotRespondRanges[axis]}
                                                            onChange={(e) => updateExecutionRequirements('mustNotRespondRanges', {
                                                                ...requirements.mustNotRespondRanges,
                                                                [axis]: parseFloat(e.target.value) || 0
                                                            })}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                        </div>

                        {/* Overall Statistics */}
                        <div className="bg-white rounded-lg shadow p-4 mb-4">
                            <h3 className="font-semibold mb-2">Overall Statistics</h3>
                            <div className="grid grid-cols-4 gap-4 text-center">
                                <div>
                                    <div className="text-lg font-bold text-green-600">{formatMsToTime(overallStats.min)}</div>
                                    <div className="text-sm text-gray-600">Min</div>
                                </div>
                                <div>
                                    <div className="text-lg font-bold text-blue-600">{formatMsToTime(overallStats.avg)}</div>
                                    <div className="text-sm text-gray-600">Avg</div>
                                </div>
                                <div>
                                    <div className="text-lg font-bold text-red-600">{formatMsToTime(overallStats.max)}</div>
                                    <div className="text-sm text-gray-600">Max</div>
                                </div>
                                <div>
                                    <div className="text-lg font-bold text-gray-600">{overallStats.total}</div>
                                    <div className="text-sm text-gray-600">Count</div>
                                </div>
                            </div>
                            {requirements.enabled && (
                                <div className="mt-3 text-center border-t pt-3">
                                    <div className="text-sm">
                                        Pass: <span className="text-green-600 font-bold">{overallStats.passed}</span> /
                                        Fail: <span className="text-red-600 font-bold">{overallStats.failed}</span>
                                        <span className="ml-2">({overallStats.passRate.toFixed(1)}%)</span>
                                    </div>
                                </div>
                            )}
                            <div className="mt-4">
                                <h4 className="text-sm font-semibold text-gray-700 uppercase tracking-wide">Axis Breakdown</h4>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mt-2 text-sm">
                                    {axisSummaries.map(({ axis, stats }) => (
                                        <div key={axis} className="border rounded-lg p-3 bg-gray-50">
                                            <div className="flex items-center justify-between text-xs text-gray-500">
                                                <span className="font-semibold text-gray-700">{axis}-Axis</span>
                                                <span>{stats.total} pts</span>
                                            </div>
                                            <div className="mt-2 flex justify-between text-xs">
                                                <span className="text-gray-600">Min</span>
                                                <span className="font-mono font-semibold text-green-600">{stats.total === 0 ? '-' : formatMsToTime(stats.min)}</span>
                                            </div>
                                            <div className="flex justify-between text-xs mt-1">
                                                <span className="text-gray-600">Avg</span>
                                                <span className="font-mono font-semibold text-blue-600">{stats.total === 0 ? '-' : formatMsToTime(stats.avg)}</span>
                                            </div>
                                            <div className="flex justify-between text-xs mt-1">
                                                <span className="text-gray-600">Max</span>
                                                <span className="font-mono font-semibold text-red-600">{stats.total === 0 ? '-' : formatMsToTime(stats.max)}</span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>

                        {/* Error Events Grouped */}
                        {Object.keys(errorsByNumber).length > 0 && (
                            <div className="bg-yellow-50 rounded-lg shadow p-4 mb-4">
                                <h3 className="font-semibold mb-2">Error Events (Grouped)</h3>
                                <div className="space-y-2">
                                    {Object.entries(errorsByNumber).map(([errorNum, errors]) => (
                                        <div key={errorNum} className="bg-white rounded p-2 border border-yellow-200">
                                            <div className="font-medium text-sm">Error #{errorNum}</div>
                                            {errors.map(err => (
                                                <div key={err.id} className="text-xs text-gray-600 ml-2">
                                                    {err.note}
                                                </div>
                                            ))}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Per-Axis Tables */}
                        <div className="space-y-4">
                                {Object.entries(axisGroups).map(([axisKey, axisTimestamps]) => {
                                    const isUngrouped = axisKey === UNGROUPED_BUCKET;
                                    const axis = isUngrouped ? null : axisKey[0];
                                    const direction = isUngrouped ? null : axisKey[1];
                                    const axisStats = isUngrouped
                                        ? getStatistics(axisTimestamps, requirements)
                                        : getAxisStatistics(axisTimestamps, axis, direction, requirements);
                                    const distanceDetails = !isUngrouped ? getDistanceDetailsForAxisKey(currentTestCase, axisKey) : null;
                                    const distance = distanceDetails?.value ?? null;
                                    const axisHasComparableSamples = axisTimestamps.some(ts =>
                                        !ts.isError && ts.latencyMs != null && !ts.excludeFromStats
                                    );
                                    const diffRow = sessionDiffAxisMap[axisKey];
                                    const axisAnnotation = diffAnnotations[axisKey];

                                    return (
                                        <div key={axisKey} className="bg-white rounded-lg shadow overflow-hidden">
                                            <div className="p-4 bg-gray-50 border-b">
                                                <div className="flex items-center justify-between flex-wrap gap-2">
                                                    <div className="flex items-center flex-wrap gap-2">
                                                        <h3 className="font-semibold flex items-center gap-2 flex-wrap">
                                                            <span>{axisKey}</span>
                                                            {!isUngrouped && distanceDetails?.source === 'manual' && (
                                                                <span className="inline-flex items-center px-2 py-0.5 text-xs font-semibold rounded-full bg-emerald-100 text-emerald-800">Manual override</span>
                                                            )}
                                                            {!isUngrouped && distanceDetails?.source === 'template' && (
                                                                <span className="inline-flex items-center px-2 py-0.5 text-xs font-semibold rounded-full bg-indigo-100 text-indigo-800">
                                                                    Template{distanceDetails.templateName ? ` Â· ${distanceDetails.templateName}` : ''}
                                                                </span>
                                                            )}
                                                        </h3>
                                                        {isUngrouped && (
                                                            <span className="inline-flex items-center px-2 py-0.5 text-xs font-semibold rounded-full bg-yellow-100 text-yellow-800">
                                                                âš ï¸ Needs axis tags
                                                            </span>
                                                        )}
                                                    </div>
                                                    <div className="flex flex-wrap items-center gap-2 text-sm text-gray-600">
                                                        <span>
                                                            Min: {formatMsToTime(axisStats.min)} |
                                                            Avg: {formatMsToTime(axisStats.avg)} |
                                                            Max: {formatMsToTime(axisStats.max)}
                                                            {requirements.enabled && (
                                                                <span className="ml-2">
                                                                    | Pass: {axisStats.passRate.toFixed(1)}% ({axisStats.passed}/{axisStats.total})
                                                                </span>
                                                            )}
                                                        </span>
                                                        {!isUngrouped && (
                                                            <button
                                                                onClick={() => openAxisSelectionPanel(activeTestCase, activeExecution, axisKey)}
                                                                disabled={!axisHasComparableSamples}
                                                                className={`inline-flex items-center gap-1 ${axisHasComparableSamples ? 'text-blue-600 hover:text-blue-800' : 'text-gray-400 cursor-not-allowed'}`}
                                                                title={axisHasComparableSamples ? 'Add this axis to the comparison view' : 'No valid samples to compare'}
                                                            >
                                                                <Icon name="git-compare" /> Compare axis
                                                            </button>
                                                        )}
                                                    </div>
                                                    {diffRow && (
                                                        <div className="flex flex-wrap items-center gap-2 text-xs text-gray-600 mt-2">
                                                            {['min', 'avg', 'max'].map(metric => (
                                                                <span
                                                                    key={metric}
                                                                    className={`inline-flex items-center px-2 py-0.5 rounded-full font-semibold ${getDeltaBadgeClasses(diffRow.delta[metric])}`}
                                                                >
                                                                    Î” {metric.toUpperCase()}: {formatDeltaMs(diffRow.delta[metric])}
                                                                </span>
                                                            ))}
                                                            {diffRow.fpsDelta != null && (
                                                                <span className={`inline-flex items-center px-2 py-0.5 rounded-full font-semibold ${getDeltaBadgeClasses(diffRow.fpsDelta)}`}>
                                                                    Î” FPS: {formatDeltaMs(diffRow.fpsDelta, '')}
                                                                </span>
                                                            )}
                                                            {diffRow.hardwareDiff && (
                                                                <span
                                                                    className="inline-flex items-center px-2 py-0.5 rounded-full bg-amber-100 text-amber-800 font-semibold"
                                                                    title={`Baseline: ${diffRow.hardwareDiff.baseline}\nCandidate: ${diffRow.hardwareDiff.candidate}`}
                                                                >
                                                                    Hardware mismatch
                                                                </span>
                                                            )}
                                                            {!isUngrouped && (
                                                                <button
                                                                    onClick={() => handleDiffAnnotation(axisKey)}
                                                                    className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-blue-50 text-blue-700"
                                                                >
                                                                    <Icon name="pin" /> {axisAnnotation ? 'Edit pin' : 'Pin note'}
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}
                                                    {axisAnnotation && (
                                                        <div className="text-xs text-amber-700 italic mt-1 flex items-start gap-1">
                                                            <Icon name="pin" />
                                                            <span>{axisAnnotation}</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="overflow-x-auto">
                                                <table className="w-full text-sm">
                                                    <thead className="bg-gray-50">
                                                        <tr>
                                                            <th className="px-4 py-2 text-left">Include</th>
                                                            <th className="px-4 py-2 text-left">Time (s)</th>
                                                            <th className="px-4 py-2 text-left">Timecode</th>
                                                            <th className="px-4 py-2 text-left">Label</th>
                                                            {isUngrouped && (
                                                                <>
                                                                    <th className="px-4 py-2 text-left">Axis</th>
                                                                    <th className="px-4 py-2 text-left">Direction</th>
                                                                </>
                                                            )}
                                                            <th className="px-4 py-2 text-left">Note</th>
                                                            <th className="px-4 py-2 text-right">Latency</th>
                                                            <th className="px-4 py-2 text-center">Actions</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {axisTimestamps.map(ts => {
                                                            const rowClass = ts.isError ? 'row-error' :
                                                                ts.excludeFromStats ? 'row-excluded' :
                                                                showPassFailHighlight && requirements.enabled && ts.latencyMs ?
                                                                    (ts.latencyMs <= requirements.maxLatency ? 'row-pass' : 'row-fail') : '';

                                                            return (
                                                                <tr key={ts.id} className={`${rowClass} border-t hover:bg-gray-50${ts.isMarked ? ' bg-amber-50' : ''}`}>
                                                                    <td className="px-4 py-2">
                                                                        {!ts.isError && (
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={!ts.excludeFromStats}
                                                                                onChange={() => toggleMarkerInclusion(ts.id)}
                                                                                className="w-4 h-4"
                                                                            />
                                                                        )}
                                                                    </td>
                                                                    <td className="px-4 py-2 font-mono">{ts.time}</td>
                                                                    <td className="px-4 py-2 font-mono text-xs">{ts.recordIn}</td>
                                                                    <td className="px-4 py-2">
                                                                        <span className={`px-2 py-1 rounded text-xs font-medium ${
                                                                            ts.label === 'TagOn' ? 'bg-green-100 text-green-800' :
                                                                            ts.label === 'TagOff' ? 'bg-blue-100 text-blue-800' :
                                                                            'bg-red-100 text-red-800'
                                                                        }`}>
                                                                            {ts.label}
                                                                        </span>
                                                                    </td>
                                                                    {isUngrouped && (
                                                                        <>
                                                                            <td className="px-4 py-2">
                                                                                <select
                                                                                    value={ts.axis || ''}
                                                                                    onChange={(e) => updateTimestampAxisDirection(ts.id, e.target.value || '', ts.direction || '')}
                                                                                    className="w-full border rounded px-2 py-1 text-xs"
                                                                                >
                                                                                    <option value="">Select axis</option>
                                                                                    {AXES.map(axisOption => (
                                                                                        <option key={axisOption} value={axisOption}>{axisOption}</option>
                                                                                    ))}
                                                                                </select>
                                                                            </td>
                                                                            <td className="px-4 py-2">
                                                                                <select
                                                                                    value={ts.direction || ''}
                                                                                    onChange={(e) => updateTimestampAxisDirection(ts.id, ts.axis || '', e.target.value || '')}
                                                                                    className="w-full border rounded px-2 py-1 text-xs"
                                                                                >
                                                                                    <option value="">Select direction</option>
                                                                                    <option value="+">+</option>
                                                                                    <option value="-">-</option>
                                                                                </select>
                                                                            </td>
                                                                        </>
                                                                    )}
                                                                    <td className="px-4 py-2 text-xs max-w-xs">
                                                                        <div className="flex items-center gap-2">
                                                                            <span
                                                                                className={`truncate ${ts.isMarked ? 'font-semibold text-amber-700' : ''}`}
                                                                                title={ts.note || (ts.isMarked ? 'Marked for follow-up' : '')}
                                                                            >
                                                                                {ts.note || (ts.isMarked ? 'Marked' : 'â€”')}
                                                                            </span>
                                                                            {!ts.isError && (
                                                                                <>
                                                                                    <button
                                                                                        onClick={() => handleEditTimestampNote(ts.id, ts.note || '')}
                                                                                        className="text-blue-600 hover:text-blue-800"
                                                                                        title="Add or edit note"
                                                                                    >
                                                                                        <Icon name="edit" />
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => toggleTimestampMark(ts.id)}
                                                                                        className={ts.isMarked ? 'text-amber-500 hover:text-amber-600' : 'text-gray-400 hover:text-gray-600'}
                                                                                        title={ts.isMarked ? 'Remove mark' : 'Mark this measurement'}
                                                                                    >
                                                                                        <Icon name={ts.isMarked ? 'star' : 'star-off'} />
                                                                                    </button>
                                                                                </>
                                                                            )}
                                                                        </div>
                                                                    </td>
                                                                    <td className="px-4 py-2 text-right font-mono font-bold">{ts.latency || '-'}</td>
                                                                    <td className="px-4 py-2 text-center">
                                                                        <button
                                                                            onClick={() => handleDeleteTimestamp(ts.id)}
                                                                            className="text-red-600 hover:text-red-800"
                                                                        >
                                                                            <Icon name="trash-2" />
                                                                        </button>
                                                                    </td>
                                                                </tr>
                                                            );
                                                        })}
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                );
            };

            const renderTraceabilityView = () => {
                const usages = [];
                testCases.forEach(tc => {
                    tc.executions.forEach(ex => {
                        (ex.hardware || []).forEach(hw => {
                            if (!hw) return;
                            const hasDetails = hw.type || hw.name || hw.serialNumber || hw.version || hw.revision;
                            if (!hasDetails) return;
                            usages.push({ hw, tc, ex });
                        });
                    });
                });

                if (usages.length === 0) {
                    return (
                        <div className="p-6">
                            <div className="bg-white rounded-lg shadow p-6 text-center">
                                <h3 className="text-lg font-semibold mb-2">No hardware tracked yet</h3>
                                <p className="text-sm text-gray-500">Add hardware to an execution to build a coverage map.</p>
                            </div>
                        </div>
                    );
                }

                const grouped = usages.reduce((acc, entry) => {
                    const serial = (entry.hw.serialNumber || '').trim().toLowerCase();
                    const fallback = `${(entry.hw.name || entry.hw.type || 'device').toLowerCase()}-${entry.hw.id}`;
                    const key = serial || fallback;
                    if (!acc[key]) {
                        acc[key] = {
                            key,
                            serial: entry.hw.serialNumber || '',
                            type: entry.hw.type || '',
                            name: entry.hw.name || '',
                            version: entry.hw.version || '',
                            revision: entry.hw.revision || '',
                            notes: entry.hw.notes || '',
                            usages: []
                        };
                    }
                    acc[key].usages.push({
                        testCaseId: entry.tc.id,
                        testCaseName: entry.tc.name,
                        executionId: entry.ex.id,
                        executionName: entry.ex.name
                    });
                    return acc;
                }, {});

                const filterValue = traceabilityFilter.toLowerCase();
                const devices = Object.values(grouped)
                    .filter(device => {
                        if (!filterValue) return true;
                        return [device.serial, device.name, device.type]
                            .some(val => (val || '').toLowerCase().includes(filterValue));
                    })
                    .sort((a, b) => b.usages.length - a.usages.length);

                return (
                    <div className="p-6 space-y-4">
                        <div className="flex flex-wrap items-center justify-between gap-3">
                            <div>
                                <h2 className="text-2xl font-bold">Device Traceability</h2>
                                <p className="text-sm text-gray-500">See which executions each device participated in.</p>
                            </div>
                            <input
                                type="text"
                                value={traceabilityFilter}
                                onChange={(e) => setTraceabilityFilter(e.target.value)}
                                className="border rounded px-3 py-2 w-64"
                                placeholder="Search by serial, name, type"
                            />
                        </div>
                        <div className="bg-white rounded-lg shadow overflow-hidden">
                            <table className="w-full text-sm">
                                <thead className="bg-gray-50">
                                    <tr>
                                        <th className="px-4 py-2 text-left">Type</th>
                                        <th className="px-4 py-2 text-left">Name</th>
                                        <th className="px-4 py-2 text-left">Serial</th>
                                        <th className="px-4 py-2 text-left">Version</th>
                                        <th className="px-4 py-2 text-left">Revision</th>
                                        <th className="px-4 py-2 text-left">Usage</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {devices.length === 0 ? (
                                        <tr>
                                            <td colSpan="6" className="px-4 py-4 text-center text-gray-500">No devices match your filter.</td>
                                        </tr>
                                    ) : (
                                        devices.map(device => (
                                            <tr key={device.key} className="border-t hover:bg-gray-50">
                                                <td className="px-4 py-3 font-medium">{device.type || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.name || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.serial || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.version || 'â€”'}</td>
                                                <td className="px-4 py-3">{device.revision || 'â€”'}</td>
                                                <td className="px-4 py-3">
                                                    <div className="flex flex-wrap gap-2">
                                                        {device.usages.map((usage, index) => (
                                                            <span key={usage.executionId + index} className="px-2 py-0.5 bg-blue-100 text-blue-800 rounded-full text-xs">
                                                                {usage.testCaseName} Â· {usage.executionName}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </td>
                                            </tr>
                                        ))
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            };

            // Render comparison view
            const renderComparisonView = () => {
                const axisComparisonEntries = flattenAxisComparisonEntries(comparisonExecutions);
                const axisOptions = getComparisonAxisOptions(comparisonExecutions);
                const activeAxis = selectedComparisonAxis && axisOptions.includes(selectedComparisonAxis)
                    ? selectedComparisonAxis
                    : (axisOptions[0] || null);
                const axisMatrixRows = activeAxis
                    ? axisComparisonEntries
                        .filter(entry => entry.axisKey === activeAxis)
                        .map(entry => {
                            const tc = testCases.find(testCase => testCase.id === entry.testCaseId);
                            const ex = tc?.executions.find(exec => exec.id === entry.executionId);
                            if (!tc || !ex) return null;
                            const executionRequirements = mergeExecutionRequirements(ex.requirements);
                            const filteredTimestamps = ex.timestamps.filter(ts => {
                                if (ts.isError || ts.latencyMs == null || ts.excludeFromStats) return false;
                                if (!entry.axisKey) return true;
                                return ts.axis && ts.direction && (ts.axis + ts.direction) === entry.axisKey;
                            });
                            const stats = getStatistics(filteredTimestamps, executionRequirements);
                            const distanceDetails = entry.axisKey ? getDistanceDetailsForAxisKey(tc, entry.axisKey) : null;
                            return {
                                key: entry.key,
                                testCaseName: tc.name,
                                executionName: ex.name,
                                stats,
                                distanceDetails
                            };
                        })
                        .filter(Boolean)
                    : [];

                const hasComparisonCards = comparisonExecutions.length > 0;
                const formatStat = (stats, metric) => {
                    if (!stats || stats.total === 0) return 'â€”';
                    return `${stats[metric].toFixed(2)}ms`;
                };

                return (
                    <div className="p-6 space-y-6">
                        {CompareSessionsSummary && (
                            <CompareSessionsSummary
                                sessionDiffData={sessionDiffData}
                                sessionDiffState={sessionDiffState}
                                copyDiffStatus={copyDiffStatus}
                                onOpenModal={openCompareSessionsDialog}
                                onCopyDiff={copyDiffSummaryToClipboard}
                                describeDatasetSource={describeDatasetSource}
                                diffAnnotations={diffAnnotations}
                                onAnnotateAxis={handleDiffAnnotation}
                                formatStat={formatStat}
                                formatDeltaMs={formatDeltaMs}
                                getDeltaBadgeClasses={getDeltaBadgeClasses}
                                Icon={Icon}
                            />
                        )}
                        {!CompareSessionsSummary && (
                            <div className="bg-white rounded-lg shadow p-6">
                                <p className="text-sm text-red-600">Compare Sessions panel failed to load.</p>
                            </div>
                        )}

                        <div className="bg-white rounded-lg shadow p-6">
                            <div className="flex flex-wrap items-center justify-between gap-4">
                                <div>
                                    <h2 className="text-xl font-semibold">Axis Comparison Matrix</h2>
                                    <p className="text-sm text-gray-500">Highlight per-axis statistics across executions.</p>
                                </div>
                                <div className="flex flex-wrap gap-2">
                                    {axisOptions.map(axis => (
                                        <button
                                            key={axis}
                                            onClick={() => setSelectedComparisonAxis(axis)}
                                            className={`px-3 py-1.5 rounded-full text-sm font-semibold ${
                                                activeAxis === axis ? 'bg-blue-600 text-white' : 'bg-blue-50 text-blue-700'
                                            }`}
                                        >
                                            {axis}
                                        </button>
                                    ))}
                                </div>
                            </div>
                            <div className="mt-4">
                                {axisMatrixRows.length > 0 ? (
                                    <div className="overflow-x-auto">
                                        <table className="w-full text-sm">
                                            <thead className="bg-gray-50">
                                                <tr>
                                                    <th className="px-4 py-2 text-left">Test Case</th>
                                                    <th className="px-4 py-2 text-left">Execution</th>
                                                    <th className="px-4 py-2 text-right">Min</th>
                                                    <th className="px-4 py-2 text-right">Avg</th>
                                                    <th className="px-4 py-2 text-right">Max</th>
                                                    <th className="px-4 py-2 text-center">Samples</th>
                                                    <th className="px-4 py-2 text-left">Distance</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {axisMatrixRows.map(row => (
                                                    <tr key={row.key} className="border-b">
                                                        <td className="px-4 py-2">{row.testCaseName}</td>
                                                        <td className="px-4 py-2">{row.executionName}</td>
                                                        <td className="px-4 py-2 text-right font-mono">{row.stats.total === 0 ? 'â€”' : formatMsToTime(row.stats.min)}</td>
                                                        <td className="px-4 py-2 text-right font-mono">{row.stats.total === 0 ? 'â€”' : formatMsToTime(row.stats.avg)}</td>
                                                        <td className="px-4 py-2 text-right font-mono">{row.stats.total === 0 ? 'â€”' : formatMsToTime(row.stats.max)}</td>
                                                        <td className="px-4 py-2 text-center">{row.stats.total}</td>
                                                        <td className="px-4 py-2">
                                                            {row.distanceDetails?.value != null
                                                                ? `${row.distanceDetails.value}mm`
                                                                : 'N/A'}
                                                            {row.distanceDetails?.source === 'manual' && (
                                                                <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-800 text-xs font-semibold">Manual</span>
                                                            )}
                                                            {row.distanceDetails?.source === 'template' && (
                                                                <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-800 text-xs font-semibold">Template{row.distanceDetails.templateName ? ` Â· ${row.distanceDetails.templateName}` : ''}</span>
                                                            )}
                                                        </td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                ) : (
                                    <p className="text-sm text-gray-500">Add axis-specific cards to populate this matrix.</p>
                                )}
                            </div>
                        </div>

                        <div className="space-y-3">
                            <div className="flex items-center justify-between">
                                <h2 className="text-xl font-semibold">Execution Cards</h2>
                                {hasComparisonCards && (
                                    <button
                                        onClick={() => setComparisonExecutions([])}
                                        className="text-sm text-red-600 hover:text-red-800"
                                    >
                                        Clear all
                                    </button>
                                )}
                            </div>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {!hasComparisonCards && (
                                    <div className="bg-white rounded-lg shadow p-4 text-gray-500 text-sm">
                                        <p>No executions added to comparison yet.</p>
                                        <p className="mt-1">Use "Add to Comparison" in the execution view to populate this dashboard.</p>
                                    </div>
                                )}
                                {comparisonExecutions.map(comp => {
                                    const tc = testCases.find(testCase => testCase.id === comp.testCaseId);
                                    const ex = tc?.executions.find(exec => exec.id === comp.executionId);

                                    if (!tc || !ex) {
                                        return (
                                            <div key={comp.key} className="bg-white rounded-lg shadow p-4">
                                                <div className="flex items-center justify-between mb-2">
                                                    <p className="text-sm text-red-600">Execution not available</p>
                                                    <button
                                                        onClick={() => removeFromComparison(comp.key)}
                                                        className="text-red-600 hover:text-red-800"
                                                    >
                                                        <Icon name="x" />
                                                    </button>
                                                </div>
                                                <p className="text-xs text-gray-500">Remove this card and add it again.</p>
                                            </div>
                                        );
                                    }

                                    const executionRequirements = mergeExecutionRequirements(ex.requirements);
                                    const filteredTimestamps = ex.timestamps.filter(ts =>
                                        !ts.isError && ts.latencyMs != null && !ts.excludeFromStats
                                    );
                                    const stats = getStatistics(filteredTimestamps, executionRequirements);
                                    const axisOptionsForCard = getComparableAxisOptions(ex);
                                    const selectedAxes = comp.axisKeys || [];
                                    const activeAxis = selectedComparisonAxis;

                                    return (
                                        <div key={comp.key} className="bg-white rounded-lg shadow p-4 border border-blue-50">
                                            <div className="flex items-center justify-between mb-3">
                                                <div>
                                                    <h3 className="font-semibold">{tc.name}</h3>
                                                    <p className="text-sm text-gray-600">{ex.name}</p>
                                                    <p className="text-xs text-gray-500">Axis selections persist across sessions.</p>
                                                </div>
                                                <button
                                                    onClick={() => removeFromComparison(comp.key)}
                                                    className="text-red-600 hover:text-red-800"
                                                >
                                                    <Icon name="x" />
                                                </button>
                                            </div>
                                            {stats.total === 0 ? (
                                                <p className="text-sm text-gray-500">No valid measurements available for this execution.</p>
                                            ) : (
                                                <div className="space-y-2 text-sm">
                                                    <div className="flex justify-between">
                                                        <span className="text-gray-600">Min:</span>
                                                        <span className="font-mono font-bold text-green-600">{formatMsToTime(stats.min)}</span>
                                                    </div>
                                                    <div className="flex justify-between">
                                                        <span className="text-gray-600">Avg:</span>
                                                        <span className="font-mono font-bold text-blue-600">{formatMsToTime(stats.avg)}</span>
                                                    </div>
                                                    <div className="flex justify-between">
                                                        <span className="text-gray-600">Max:</span>
                                                        <span className="font-mono font-bold text-red-600">{formatMsToTime(stats.max)}</span>
                                                    </div>
                                                    <div className="flex justify-between border-t pt-2">
                                                        <span className="text-gray-600">Count:</span>
                                                        <span className="font-bold">{stats.total}</span>
                                                    </div>
                                                    {executionRequirements.enabled && (
                                                        <div className="flex justify-between border-t pt-2">
                                                            <span className="text-gray-600">Pass Rate:</span>
                                                            <span className="font-bold">{stats.passRate.toFixed(1)}%</span>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                            <div className="mt-4 border-t pt-3 space-y-2">
                                                <div className="flex items-center justify-between">
                                                    <p className="text-xs uppercase text-gray-500 tracking-wide">Axis filters</p>
                                                    <button
                                                        onClick={() => openAxisSelectionPanel(comp.testCaseId, comp.executionId)}
                                                        className="text-xs text-blue-600 hover:text-blue-800"
                                                    >
                                                        Bulk edit
                                                    </button>
                                                </div>
                                                {axisOptionsForCard.length === 0 ? (
                                                    <p className="text-sm text-gray-500">No tagged axes yet. Assign directions in the execution view.</p>
                                                ) : (
                                                    <div className="space-y-2">
                                                        {axisOptionsForCard.map(option => {
                                                            const checked = selectedAxes.includes(option.key);
                                                            return (
                                                                <label key={option.key} className="flex items-center justify-between text-sm border rounded px-3 py-1.5">
                                                                    <div className="flex items-center gap-2">
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={checked}
                                                                            onChange={(e) => handleComparisonAxisToggle(comp.key, option.key, e.target.checked)}
                                                                        />
                                                                        <span className="font-medium">{option.key}</span>
                                                                        <span className="text-xs text-gray-500">{option.count} samples</span>
                                                                        {activeAxis === option.key && (
                                                                            <span className="inline-flex items-center px-2 py-0.5 rounded-full bg-blue-100 text-blue-800 text-xs">Active</span>
                                                                        )}
                                                                    </div>
                                                                </label>
                                                            );
                                                        })}
                                                    </div>
                                                )}
                                                <p className="text-xs text-gray-500">Checked axes feed the comparison matrix. Uncheck to hide them without leaving this page.</p>
                                                {selectedAxes.length === 0 && (
                                                    <p className="text-xs text-amber-700">No axes selected yet â€” toggle one above to start a comparison.</p>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                );
            };

            // Main render
            return (
                <div className="min-h-screen bg-gray-100">
                    {/* Header */}
                    <div className="bg-blue-600 text-white shadow-lg no-print">
                        <div className="px-6 py-4">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h1 className="text-2xl font-bold">Hardware Latency Tester</h1>
                                    <p className="text-blue-100 text-sm font-semibold">v3.9 Release Candidate 3 (Evaluation Only)</p>
                                    <p className="text-xs text-amber-200 uppercase tracking-wide flex items-center gap-1">
                                        <Icon name="alert-triangle" /> Release Candidate 3 - not approved for production
                                    </p>
                                </div>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={() => importRef.current?.click()}
                                        className="px-4 py-2 bg-blue-700 rounded hover:bg-blue-800"
                                    >
                                        <Icon name="upload" /> Import
                                    </button>
                                    <button
                                        onClick={handleExportJSON}
                                        className="px-4 py-2 bg-blue-700 rounded hover:bg-blue-800"
                                        disabled={testCases.length === 0}
                                    >
                                        <Icon name="download" /> Export
                                    </button>
                                    <button
                                        onClick={openCompareSessionsDialog}
                                        disabled={executionOptions.length < 2}
                                        className={`px-4 py-2 rounded ${executionOptions.length >= 2 ? 'bg-blue-700 hover:bg-blue-800' : 'bg-blue-300 cursor-not-allowed'}`}
                                    >
                                        <Icon name="link" /> Compare Sessions
                                    </button>
                                    {currentTestCase && currentExecution && (
                                        <button
                                            onClick={() => openAxisSelectionPanel(activeTestCase, activeExecution)}
                                            disabled={!currentExecutionHasComparableSamples}
                                            title={currentExecutionHasComparableSamples ? 'Add the active execution to the comparison dashboard' : 'No valid latency measurements available for comparison'}
                                            className={`px-4 py-2 rounded ${currentExecutionHasComparableSamples ? 'bg-blue-700 hover:bg-blue-800' : 'bg-blue-300 cursor-not-allowed'}`}
                                        >
                                            <Icon name="git-compare" /> Add to Comparison
                                        </button>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Navigation */}
                        <div className="px-6 flex space-x-1 border-t border-blue-500">
                            <button
                                onClick={() => changeView('execution')}
                                className={`px-4 py-2 ${view === 'execution' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="bar-chart" /> Execution
                            </button>
                            <button
                                onClick={() => changeView('hardware')}
                                className={`px-4 py-2 ${view === 'hardware' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="hard-drive" /> Hardware Bank
                            </button>
                            <button
                                onClick={() => changeView('comparison')}
                                className={`px-4 py-2 ${view === 'comparison' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="git-compare" /> Comparison ({comparisonExecutions.length})
                            </button>
                            <button
                                onClick={() => changeView('traceability')}
                                className={`px-4 py-2 ${view === 'traceability' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="hard-drive" /> Devices
                            </button>
                            <button
                                onClick={() => changeView('report')}
                                className={`px-4 py-2 ${view === 'report' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="file-text" /> Report
                            </button>
                            <button
                                onClick={() => changeView('defects')}
                                className={`px-4 py-2 ${view === 'defects' ? 'bg-blue-700' : 'hover:bg-blue-700'}`}
                            >
                                <Icon name="alert-triangle" /> Defects ({defects.length})
                            </button>
                        </div>
                    </div>

                    {/* Main Content */}
                    <div className="flex">
                        {/* Sidebar */}
                        {view === 'execution' && (
                            <div className="w-64 bg-white shadow-lg no-print" style={{ minHeight: 'calc(100vh - 140px)' }}>
                                <div className="p-4">
                                    <div className="mb-4">
                                        <h3 className="font-semibold mb-2">Test Cases</h3>
                                        <button
                                            onClick={() => runWithTemplateGuard(() => {
                                                const newTC = createNewTestCase();
                                                const firstExecution = newTC.executions[0];
                                                setTestCases([...testCases, newTC]);
                                                setActiveTestCase(newTC.id);
                                                setActiveExecution(firstExecution?.id);
                                            })}
                                            className="w-full px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 mb-2 text-sm"
                                        >
                                            <Icon name="plus" /> New Test Case
                                        </button>
                                        <div className="space-y-1">
                                            {testCases.map(tc => (
                                                <div key={tc.id}>
                                                    <div
                                                        onClick={() => runWithTemplateGuard(() => {
                                                            setActiveTestCase(tc.id);
                                                            if (tc.executions.length > 0) {
                                                                setActiveExecution(tc.executions[0].id);
                                                            }
                                                        })}
                                                        className={`px-3 py-2 rounded cursor-pointer text-sm truncate ${
                                                            activeTestCase === tc.id ? 'bg-blue-100 font-semibold' : 'hover:bg-gray-100'
                                                        }`}
                                                        title={tc.name}
                                                    >
                                                        {tc.name}
                                                    </div>
                                                    {activeTestCase === tc.id && (
                                                        <div className="ml-4 mt-1 space-y-1">
                                                            {tc.executions.map(ex => (
                                                                <div
                                                                    key={ex.id}
                                                                    onClick={() => runWithTemplateGuard(() => setActiveExecution(ex.id))}
                                                                    className={`px-2 py-1 rounded cursor-pointer text-xs truncate ${
                                                                        activeExecution === ex.id ? 'bg-green-100 font-medium' : 'hover:bg-gray-50'
                                                                    }`}
                                                                    title={ex.name}
                                                                >
                                                                    {ex.name}
                                                                </div>
                                                            ))}
                                                            <button
                                                                onClick={() => runWithTemplateGuard(() => {
                                                                    const templateId = tc.requirementTemplateId;
                                                                    const templateConfig = ensureTemplateConfig(templateId);
                                                                    const newEx = createNewExecution(tc, templateConfig, templateId);
                                                                    tc.executions.push(newEx);
                                                                    setTestCases([...testCases]);
                                                                    setActiveExecution(newEx.id);
                                                                })}
                                                                className="w-full px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700 text-xs"
                                                            >
                                                                + New Execution
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Main View */}
                        <div className="flex-1">
                            {view === 'requirements' && renderRequirementsView()}
                            {view === 'hardware' && renderHardwareLibraryView()}
                            {view === 'execution' && renderExecutionView()}
                            {view === 'comparison' && renderComparisonView()}
                            {view === 'traceability' && renderTraceabilityView()}
                            {view === 'report' && renderReportView()}
                            {view === 'defects' && renderDefectView()}
                        </div>
                    </div>

                    {renderAxisSelectionPanel()}
                    {renderCompareSessionsModal()}
                    {renderImportModal()}

                    <input
                        ref={importRef}
                        type="file"
                        accept=".csv,.json"
                        onChange={handleFileImport}
                        className="hidden"
                    />
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<LatencyTester />);
    </script>
</body>
</html>
